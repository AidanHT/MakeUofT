{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Quant\\\\Documents\\\\Programming\\\\Projects\\\\Hackathon\\\\MakeUofT\\\\frontend\\\\src\\\\components\\\\PoseTracker.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport Webcam from 'react-webcam';\nimport { Camera } from '@mediapipe/camera_utils';\nimport { Pose } from '@mediapipe/pose';\nimport './PoseTracker.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst PoseTracker = ({\n  userPreferences\n}) => {\n  _s();\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n  const poseRef = useRef(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [poseAccuracy, setPoseAccuracy] = useState(0);\n  const [segmentAccuracies, setSegmentAccuracies] = useState({});\n  const [poseFeedback, setPoseFeedback] = useState('');\n  const [wsConnection, setWsConnection] = useState(null);\n  const [selectedPose, setSelectedPose] = useState(null);\n  const videoConstraints = {\n    width: 640,\n    height: 480,\n    facingMode: 'user'\n  };\n  const calculatePoseAccuracy = (userLandmarks, targetPose) => {\n    if (!targetPose || !userLandmarks) return {\n      total: 0,\n      segments: {}\n    };\n\n    // Define body segments with their corresponding landmark indices\n    const bodySegments = {\n      head: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      upperBody: [11, 12, 13, 14, 15, 16],\n      // shoulders, elbows, wrists\n      torso: [11, 12, 23, 24],\n      // shoulders to hips\n      lowerBody: [23, 24, 25, 26, 27, 28] // hips to ankles\n    };\n\n    // Define key points that must be visible for each segment\n    const requiredPoints = {\n      head: [0, 1, 4],\n      // Nose and eyes\n      upperBody: [11, 12],\n      // Shoulders\n      torso: [11, 12, 23, 24],\n      // Shoulders and hips\n      lowerBody: [23, 24, 25, 26] // Hips and knees\n    };\n\n    // Helper function to normalize pose relative to shoulders\n    const normalizePose = landmarks => {\n      const leftShoulder = landmarks[11];\n      const rightShoulder = landmarks[12];\n      const shoulderCenterX = (leftShoulder.x + rightShoulder.x) / 2;\n      const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2;\n      const shoulderWidth = Math.sqrt(Math.pow(rightShoulder.x - leftShoulder.x, 2) + Math.pow(rightShoulder.y - leftShoulder.y, 2));\n      return landmarks.map(landmark => ({\n        x: (landmark.x - shoulderCenterX) / shoulderWidth,\n        y: (landmark.y - shoulderCenterY) / shoulderWidth,\n        visibility: landmark.visibility\n      }));\n    };\n\n    // Normalize both poses\n    const normalizedUser = normalizePose(userLandmarks);\n    const normalizedTarget = normalizePose(targetPose.landmarks);\n    let segmentAccuracies = {};\n    let visibleSegments = 0;\n\n    // Calculate accuracy for each body segment\n    for (const [segment, points] of Object.entries(bodySegments)) {\n      // Check if required points are visible\n      const requiredVisible = requiredPoints[segment].every(index => {\n        const userPoint = normalizedUser[index];\n        const targetPoint = normalizedTarget[index];\n        return userPoint.visibility > 0.5 && targetPoint.visibility > 0.5;\n      });\n      if (!requiredVisible) {\n        continue; // Skip this segment if required points aren't visible\n      }\n      let segmentTotal = 0;\n      let segmentPoints = 0;\n\n      // Calculate accuracies for points\n      points.forEach(index => {\n        const userLandmark = normalizedUser[index];\n        const targetLandmark = normalizedTarget[index];\n\n        // Check if point is visible enough in both poses\n        if (userLandmark.visibility > 0.5 && targetLandmark.visibility > 0.5) {\n          // Calculate angle between points relative to shoulder center\n          const userAngle = Math.atan2(userLandmark.y, userLandmark.x);\n          const targetAngle = Math.atan2(targetLandmark.y, targetLandmark.x);\n          const angleDiff = Math.abs(userAngle - targetAngle);\n\n          // Calculate position difference\n          const distance = Math.sqrt(Math.pow(userLandmark.x - targetLandmark.x, 2) + Math.pow(userLandmark.y - targetLandmark.y, 2));\n\n          // Combine angle and distance accuracy\n          const angleAccuracy = Math.max(0, 1 - angleDiff / Math.PI);\n          const distanceAccuracy = Math.max(0, 1 - distance / 0.5);\n          const pointAccuracy = angleAccuracy * 0.7 + distanceAccuracy * 0.3;\n\n          // Add to segment total with visibility weight\n          const weight = Math.min(userLandmark.visibility, targetLandmark.visibility);\n          segmentTotal += pointAccuracy * weight;\n          segmentPoints += weight;\n        }\n      });\n\n      // Calculate segment accuracy if we have points\n      if (segmentPoints > 0) {\n        const rawAccuracy = segmentTotal / segmentPoints * 100;\n        segmentAccuracies[segment] = {\n          accuracy: Math.min(100, Math.max(0, rawAccuracy)),\n          visibility: segmentPoints / points.length\n        };\n        visibleSegments++;\n      }\n    }\n\n    // Calculate overall accuracy\n    if (visibleSegments === 0) return {\n      total: 0,\n      segments: {}\n    };\n    let totalAccuracy = 0;\n    let totalWeight = 0;\n\n    // Weight segments differently\n    const segmentWeights = {\n      head: 1,\n      upperBody: 1.2,\n      torso: 1.2,\n      lowerBody: 1\n    };\n    for (const [segment, data] of Object.entries(segmentAccuracies)) {\n      const weight = segmentWeights[segment] * data.visibility;\n      totalAccuracy += data.accuracy * weight;\n      totalWeight += weight;\n    }\n    return {\n      total: Math.round(totalWeight > 0 ? totalAccuracy / totalWeight : 0),\n      segments: segmentAccuracies\n    };\n  };\n  const onResults = useCallback(results => {\n    if (!canvasRef.current || !results.poseLandmarks) return;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext('2d');\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight;\n\n    // Set canvas dimensions to match video\n    canvasElement.width = videoWidth;\n    canvasElement.height = videoHeight;\n\n    // Calculate pose accuracy if we have a selected pose\n    if (selectedPose && selectedPose.landmarks) {\n      const accuracyData = calculatePoseAccuracy(results.poseLandmarks, selectedPose);\n      setPoseAccuracy(accuracyData.total);\n      setSegmentAccuracies(accuracyData.segments);\n    }\n\n    // Clear canvas\n    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n    // Draw pose landmarks\n    if (results.poseLandmarks) {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n      // Mirror the canvas context\n      canvasCtx.scale(-1, 1);\n      canvasCtx.translate(-videoWidth, 0);\n\n      // Draw connectors\n      canvasCtx.lineWidth = 3;\n\n      // Draw pose connections\n      function drawConnection(landmarks, start, end, color) {\n        const startPoint = landmarks[start];\n        const endPoint = landmarks[end];\n        if (startPoint.visibility > 0.5 && endPoint.visibility > 0.5) {\n          canvasCtx.beginPath();\n          canvasCtx.moveTo(startPoint.x * videoWidth, startPoint.y * videoHeight);\n          canvasCtx.lineTo(endPoint.x * videoWidth, endPoint.y * videoHeight);\n          canvasCtx.strokeStyle = color;\n          canvasCtx.stroke();\n        }\n      }\n      const landmarks = results.poseLandmarks;\n\n      // Draw body parts with different colors\n      // Upper body (green)\n      const upperBodyColor = '#00FF00';\n      drawConnection(landmarks, 11, 12, upperBodyColor); // shoulders\n      drawConnection(landmarks, 11, 13, upperBodyColor); // left upper arm\n      drawConnection(landmarks, 13, 15, upperBodyColor); // left lower arm\n      drawConnection(landmarks, 12, 14, upperBodyColor); // right upper arm\n      drawConnection(landmarks, 14, 16, upperBodyColor); // right lower arm\n\n      // Head (red)\n      const headColor = '#FF0000';\n      drawConnection(landmarks, 0, 1, headColor);\n      drawConnection(landmarks, 1, 2, headColor);\n      drawConnection(landmarks, 2, 3, headColor);\n      drawConnection(landmarks, 3, 7, headColor);\n      drawConnection(landmarks, 0, 4, headColor);\n      drawConnection(landmarks, 4, 5, headColor);\n      drawConnection(landmarks, 5, 6, headColor);\n      drawConnection(landmarks, 6, 8, headColor);\n\n      // Torso (blue)\n      const torsoColor = '#0000FF';\n      drawConnection(landmarks, 11, 23, torsoColor); // left shoulder to hip\n      drawConnection(landmarks, 12, 24, torsoColor); // right shoulder to hip\n      drawConnection(landmarks, 23, 24, torsoColor); // hips\n\n      // Lower body (yellow)\n      const lowerBodyColor = '#FFFF00';\n      drawConnection(landmarks, 23, 25, lowerBodyColor); // left hip to knee\n      drawConnection(landmarks, 25, 27, lowerBodyColor); // left knee to ankle\n      drawConnection(landmarks, 24, 26, lowerBodyColor); // right hip to knee\n      drawConnection(landmarks, 26, 28, lowerBodyColor); // right knee to ankle\n\n      // Draw landmarks\n      landmarks.forEach((landmark, index) => {\n        if (landmark.visibility > 0.5) {\n          canvasCtx.beginPath();\n          canvasCtx.arc(landmark.x * videoWidth, landmark.y * videoHeight, 5, 0, 2 * Math.PI);\n          canvasCtx.fillStyle = '#FFFFFF';\n          canvasCtx.fill();\n          canvasCtx.strokeStyle = '#000000';\n          canvasCtx.stroke();\n        }\n      });\n      canvasCtx.restore();\n    }\n  }, [selectedPose]);\n  useEffect(() => {\n    let pose = null;\n    let camera = null;\n    const initializePose = async () => {\n      try {\n        pose = new Pose({\n          locateFile: file => {\n            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n          }\n        });\n        pose.setOptions({\n          modelComplexity: 1,\n          smoothLandmarks: true,\n          enableSegmentation: false,\n          smoothSegmentation: false,\n          minDetectionConfidence: 0.5,\n          minTrackingConfidence: 0.5\n        });\n        pose.onResults(onResults);\n        if (webcamRef.current && webcamRef.current.video) {\n          camera = new Camera(webcamRef.current.video, {\n            onFrame: async () => {\n              if (webcamRef.current && webcamRef.current.video) {\n                await pose.send({\n                  image: webcamRef.current.video\n                });\n              }\n            },\n            width: 640,\n            height: 480\n          });\n          camera.start();\n          setIsLoading(false);\n        }\n      } catch (err) {\n        console.error('Error initializing pose detection:', err);\n        setError('Failed to initialize pose detection. Please try refreshing the page.');\n        setIsLoading(false);\n      }\n    };\n    initializePose();\n    return () => {\n      if (camera) {\n        camera.stop();\n      }\n      if (pose) {\n        pose.close();\n      }\n    };\n  }, [onResults]);\n  useEffect(() => {\n    // Initialize WebSocket connection\n    const ws = new WebSocket('ws://localhost:8000/ws/pose-feedback');\n    ws.onopen = () => {\n      console.log('Connected to feedback server');\n      setWsConnection(ws);\n    };\n    ws.onmessage = event => {\n      setPoseFeedback(event.data);\n    };\n    ws.onerror = error => {\n      console.error('WebSocket error:', error);\n    };\n    return () => {\n      if (ws) {\n        ws.close();\n      }\n    };\n  }, []);\n\n  // Send pose data to backend when accuracy updates\n  useEffect(() => {\n    if (wsConnection && selectedPose && Object.keys(segmentAccuracies).length > 0) {\n      const poseData = {\n        pose_name: selectedPose.name || 'unknown pose',\n        overall_accuracy: poseAccuracy,\n        segment_accuracies: segmentAccuracies\n      };\n      wsConnection.send(JSON.stringify(poseData));\n    }\n  }, [poseAccuracy, segmentAccuracies, selectedPose, wsConnection]);\n\n  // Load initial pose based on user preferences\n  useEffect(() => {\n    const loadPose = async () => {\n      try {\n        // You would typically load this from your backend or a static file\n        const response = await fetch('/pose_results/tree-pose_pose.json');\n        const poseData = await response.json();\n        setSelectedPose(poseData);\n      } catch (err) {\n        console.error('Error loading pose data:', err);\n        setError('Failed to load pose data. Please try refreshing the page.');\n      }\n    };\n    if (userPreferences) {\n      loadPose();\n    }\n  }, [userPreferences]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"pose-tracker\",\n    children: [isLoading && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"loading\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Loading pose detector... Please wait a moment.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 373,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        style: {\n          fontSize: '0.9em',\n          color: '#666'\n        },\n        children: \"This may take a few seconds to initialize.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 374,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 372,\n      columnNumber: 17\n    }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"error\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: error\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 381,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => window.location.reload(),\n        className: \"retry-button\",\n        children: \"Retry\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 382,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 380,\n      columnNumber: 17\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"camera-container\",\n      children: [/*#__PURE__*/_jsxDEV(Webcam, {\n        ref: webcamRef,\n        className: \"webcam\",\n        mirrored: true,\n        videoConstraints: videoConstraints\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 391,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        className: \"pose-canvas\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 397,\n        columnNumber: 17\n      }, this), selectedPose && selectedPose.landmarks && Object.keys(segmentAccuracies).length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"accuracy-display\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"accuracy-overall\",\n          children: [\"Overall Accuracy: \", poseAccuracy, \"%\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 400,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"accuracy-segments\",\n          children: Object.entries(segmentAccuracies).map(([segment, data]) => /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"accuracy-segment\",\n            children: [segment.charAt(0).toUpperCase() + segment.slice(1), \": \", Math.round(data.accuracy), \"%\"]\n          }, segment, true, {\n            fileName: _jsxFileName,\n            lineNumber: 405,\n            columnNumber: 33\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 403,\n          columnNumber: 25\n        }, this), poseFeedback && /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"pose-feedback\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"feedback-title\",\n            children: \"Instructor Feedback:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 412,\n            columnNumber: 33\n          }, this), poseFeedback]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 411,\n          columnNumber: 29\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 399,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 390,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 370,\n    columnNumber: 9\n  }, this);\n};\n_s(PoseTracker, \"UPUgzfvZ4MGJ/HGo+qhKPoMEQME=\");\n_c = PoseTracker;\nexport default PoseTracker;\nvar _c;\n$RefreshReg$(_c, \"PoseTracker\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","Webcam","Camera","Pose","jsxDEV","_jsxDEV","PoseTracker","userPreferences","_s","webcamRef","canvasRef","poseRef","isLoading","setIsLoading","error","setError","poseAccuracy","setPoseAccuracy","segmentAccuracies","setSegmentAccuracies","poseFeedback","setPoseFeedback","wsConnection","setWsConnection","selectedPose","setSelectedPose","videoConstraints","width","height","facingMode","calculatePoseAccuracy","userLandmarks","targetPose","total","segments","bodySegments","head","upperBody","torso","lowerBody","requiredPoints","normalizePose","landmarks","leftShoulder","rightShoulder","shoulderCenterX","x","shoulderCenterY","y","shoulderWidth","Math","sqrt","pow","map","landmark","visibility","normalizedUser","normalizedTarget","visibleSegments","segment","points","Object","entries","requiredVisible","every","index","userPoint","targetPoint","segmentTotal","segmentPoints","forEach","userLandmark","targetLandmark","userAngle","atan2","targetAngle","angleDiff","abs","distance","angleAccuracy","max","PI","distanceAccuracy","pointAccuracy","weight","min","rawAccuracy","accuracy","length","totalAccuracy","totalWeight","segmentWeights","data","round","onResults","results","current","poseLandmarks","canvasElement","canvasCtx","getContext","videoWidth","video","videoHeight","accuracyData","clearRect","save","scale","translate","lineWidth","drawConnection","start","end","color","startPoint","endPoint","beginPath","moveTo","lineTo","strokeStyle","stroke","upperBodyColor","headColor","torsoColor","lowerBodyColor","arc","fillStyle","fill","restore","pose","camera","initializePose","locateFile","file","setOptions","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","minDetectionConfidence","minTrackingConfidence","onFrame","send","image","err","console","stop","close","ws","WebSocket","onopen","log","onmessage","event","onerror","keys","poseData","pose_name","name","overall_accuracy","segment_accuracies","JSON","stringify","loadPose","response","fetch","json","className","children","fileName","_jsxFileName","lineNumber","columnNumber","style","fontSize","onClick","window","location","reload","ref","mirrored","charAt","toUpperCase","slice","_c","$RefreshReg$"],"sources":["C:/Users/Quant/Documents/Programming/Projects/Hackathon/MakeUofT/frontend/src/components/PoseTracker.js"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\r\nimport Webcam from 'react-webcam';\r\nimport { Camera } from '@mediapipe/camera_utils';\r\nimport { Pose } from '@mediapipe/pose';\r\nimport './PoseTracker.css';\r\n\r\nconst PoseTracker = ({ userPreferences }) => {\r\n    const webcamRef = useRef(null);\r\n    const canvasRef = useRef(null);\r\n    const poseRef = useRef(null);\r\n    const [isLoading, setIsLoading] = useState(true);\r\n    const [error, setError] = useState(null);\r\n    const [poseAccuracy, setPoseAccuracy] = useState(0);\r\n    const [segmentAccuracies, setSegmentAccuracies] = useState({});\r\n    const [poseFeedback, setPoseFeedback] = useState('');\r\n    const [wsConnection, setWsConnection] = useState(null);\r\n    const [selectedPose, setSelectedPose] = useState(null);\r\n\r\n    const videoConstraints = {\r\n        width: 640,\r\n        height: 480,\r\n        facingMode: 'user',\r\n    };\r\n\r\n    const calculatePoseAccuracy = (userLandmarks, targetPose) => {\r\n        if (!targetPose || !userLandmarks) return { total: 0, segments: {} };\r\n\r\n        // Define body segments with their corresponding landmark indices\r\n        const bodySegments = {\r\n            head: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\r\n            upperBody: [11, 12, 13, 14, 15, 16], // shoulders, elbows, wrists\r\n            torso: [11, 12, 23, 24], // shoulders to hips\r\n            lowerBody: [23, 24, 25, 26, 27, 28] // hips to ankles\r\n        };\r\n\r\n        // Define key points that must be visible for each segment\r\n        const requiredPoints = {\r\n            head: [0, 1, 4], // Nose and eyes\r\n            upperBody: [11, 12], // Shoulders\r\n            torso: [11, 12, 23, 24], // Shoulders and hips\r\n            lowerBody: [23, 24, 25, 26] // Hips and knees\r\n        };\r\n\r\n        // Helper function to normalize pose relative to shoulders\r\n        const normalizePose = (landmarks) => {\r\n            const leftShoulder = landmarks[11];\r\n            const rightShoulder = landmarks[12];\r\n\r\n            const shoulderCenterX = (leftShoulder.x + rightShoulder.x) / 2;\r\n            const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2;\r\n            const shoulderWidth = Math.sqrt(\r\n                Math.pow(rightShoulder.x - leftShoulder.x, 2) +\r\n                Math.pow(rightShoulder.y - leftShoulder.y, 2)\r\n            );\r\n\r\n            return landmarks.map(landmark => ({\r\n                x: (landmark.x - shoulderCenterX) / shoulderWidth,\r\n                y: (landmark.y - shoulderCenterY) / shoulderWidth,\r\n                visibility: landmark.visibility\r\n            }));\r\n        };\r\n\r\n        // Normalize both poses\r\n        const normalizedUser = normalizePose(userLandmarks);\r\n        const normalizedTarget = normalizePose(targetPose.landmarks);\r\n\r\n        let segmentAccuracies = {};\r\n        let visibleSegments = 0;\r\n\r\n        // Calculate accuracy for each body segment\r\n        for (const [segment, points] of Object.entries(bodySegments)) {\r\n            // Check if required points are visible\r\n            const requiredVisible = requiredPoints[segment].every(index => {\r\n                const userPoint = normalizedUser[index];\r\n                const targetPoint = normalizedTarget[index];\r\n                return userPoint.visibility > 0.5 && targetPoint.visibility > 0.5;\r\n            });\r\n\r\n            if (!requiredVisible) {\r\n                continue; // Skip this segment if required points aren't visible\r\n            }\r\n\r\n            let segmentTotal = 0;\r\n            let segmentPoints = 0;\r\n\r\n            // Calculate accuracies for points\r\n            points.forEach(index => {\r\n                const userLandmark = normalizedUser[index];\r\n                const targetLandmark = normalizedTarget[index];\r\n\r\n                // Check if point is visible enough in both poses\r\n                if (userLandmark.visibility > 0.5 && targetLandmark.visibility > 0.5) {\r\n                    // Calculate angle between points relative to shoulder center\r\n                    const userAngle = Math.atan2(userLandmark.y, userLandmark.x);\r\n                    const targetAngle = Math.atan2(targetLandmark.y, targetLandmark.x);\r\n                    const angleDiff = Math.abs(userAngle - targetAngle);\r\n\r\n                    // Calculate position difference\r\n                    const distance = Math.sqrt(\r\n                        Math.pow(userLandmark.x - targetLandmark.x, 2) +\r\n                        Math.pow(userLandmark.y - targetLandmark.y, 2)\r\n                    );\r\n\r\n                    // Combine angle and distance accuracy\r\n                    const angleAccuracy = Math.max(0, 1 - (angleDiff / Math.PI));\r\n                    const distanceAccuracy = Math.max(0, 1 - (distance / 0.5));\r\n                    const pointAccuracy = (angleAccuracy * 0.7 + distanceAccuracy * 0.3);\r\n\r\n                    // Add to segment total with visibility weight\r\n                    const weight = Math.min(userLandmark.visibility, targetLandmark.visibility);\r\n                    segmentTotal += pointAccuracy * weight;\r\n                    segmentPoints += weight;\r\n                }\r\n            });\r\n\r\n            // Calculate segment accuracy if we have points\r\n            if (segmentPoints > 0) {\r\n                const rawAccuracy = (segmentTotal / segmentPoints) * 100;\r\n                segmentAccuracies[segment] = {\r\n                    accuracy: Math.min(100, Math.max(0, rawAccuracy)),\r\n                    visibility: segmentPoints / points.length\r\n                };\r\n                visibleSegments++;\r\n            }\r\n        }\r\n\r\n        // Calculate overall accuracy\r\n        if (visibleSegments === 0) return { total: 0, segments: {} };\r\n\r\n        let totalAccuracy = 0;\r\n        let totalWeight = 0;\r\n\r\n        // Weight segments differently\r\n        const segmentWeights = {\r\n            head: 1,\r\n            upperBody: 1.2,\r\n            torso: 1.2,\r\n            lowerBody: 1\r\n        };\r\n\r\n        for (const [segment, data] of Object.entries(segmentAccuracies)) {\r\n            const weight = segmentWeights[segment] * data.visibility;\r\n            totalAccuracy += data.accuracy * weight;\r\n            totalWeight += weight;\r\n        }\r\n\r\n        return {\r\n            total: Math.round(totalWeight > 0 ? totalAccuracy / totalWeight : 0),\r\n            segments: segmentAccuracies\r\n        };\r\n    };\r\n\r\n    const onResults = useCallback((results) => {\r\n        if (!canvasRef.current || !results.poseLandmarks) return;\r\n\r\n        const canvasElement = canvasRef.current;\r\n        const canvasCtx = canvasElement.getContext('2d');\r\n        const videoWidth = webcamRef.current.video.videoWidth;\r\n        const videoHeight = webcamRef.current.video.videoHeight;\r\n\r\n        // Set canvas dimensions to match video\r\n        canvasElement.width = videoWidth;\r\n        canvasElement.height = videoHeight;\r\n\r\n        // Calculate pose accuracy if we have a selected pose\r\n        if (selectedPose && selectedPose.landmarks) {\r\n            const accuracyData = calculatePoseAccuracy(results.poseLandmarks, selectedPose);\r\n            setPoseAccuracy(accuracyData.total);\r\n            setSegmentAccuracies(accuracyData.segments);\r\n        }\r\n\r\n        // Clear canvas\r\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\r\n\r\n        // Draw pose landmarks\r\n        if (results.poseLandmarks) {\r\n            canvasCtx.save();\r\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\r\n\r\n            // Mirror the canvas context\r\n            canvasCtx.scale(-1, 1);\r\n            canvasCtx.translate(-videoWidth, 0);\r\n\r\n            // Draw connectors\r\n            canvasCtx.lineWidth = 3;\r\n\r\n            // Draw pose connections\r\n            function drawConnection(landmarks, start, end, color) {\r\n                const startPoint = landmarks[start];\r\n                const endPoint = landmarks[end];\r\n\r\n                if (startPoint.visibility > 0.5 && endPoint.visibility > 0.5) {\r\n                    canvasCtx.beginPath();\r\n                    canvasCtx.moveTo(startPoint.x * videoWidth, startPoint.y * videoHeight);\r\n                    canvasCtx.lineTo(endPoint.x * videoWidth, endPoint.y * videoHeight);\r\n                    canvasCtx.strokeStyle = color;\r\n                    canvasCtx.stroke();\r\n                }\r\n            }\r\n\r\n            const landmarks = results.poseLandmarks;\r\n\r\n            // Draw body parts with different colors\r\n            // Upper body (green)\r\n            const upperBodyColor = '#00FF00';\r\n            drawConnection(landmarks, 11, 12, upperBodyColor); // shoulders\r\n            drawConnection(landmarks, 11, 13, upperBodyColor); // left upper arm\r\n            drawConnection(landmarks, 13, 15, upperBodyColor); // left lower arm\r\n            drawConnection(landmarks, 12, 14, upperBodyColor); // right upper arm\r\n            drawConnection(landmarks, 14, 16, upperBodyColor); // right lower arm\r\n\r\n            // Head (red)\r\n            const headColor = '#FF0000';\r\n            drawConnection(landmarks, 0, 1, headColor);\r\n            drawConnection(landmarks, 1, 2, headColor);\r\n            drawConnection(landmarks, 2, 3, headColor);\r\n            drawConnection(landmarks, 3, 7, headColor);\r\n            drawConnection(landmarks, 0, 4, headColor);\r\n            drawConnection(landmarks, 4, 5, headColor);\r\n            drawConnection(landmarks, 5, 6, headColor);\r\n            drawConnection(landmarks, 6, 8, headColor);\r\n\r\n            // Torso (blue)\r\n            const torsoColor = '#0000FF';\r\n            drawConnection(landmarks, 11, 23, torsoColor); // left shoulder to hip\r\n            drawConnection(landmarks, 12, 24, torsoColor); // right shoulder to hip\r\n            drawConnection(landmarks, 23, 24, torsoColor); // hips\r\n\r\n            // Lower body (yellow)\r\n            const lowerBodyColor = '#FFFF00';\r\n            drawConnection(landmarks, 23, 25, lowerBodyColor); // left hip to knee\r\n            drawConnection(landmarks, 25, 27, lowerBodyColor); // left knee to ankle\r\n            drawConnection(landmarks, 24, 26, lowerBodyColor); // right hip to knee\r\n            drawConnection(landmarks, 26, 28, lowerBodyColor); // right knee to ankle\r\n\r\n            // Draw landmarks\r\n            landmarks.forEach((landmark, index) => {\r\n                if (landmark.visibility > 0.5) {\r\n                    canvasCtx.beginPath();\r\n                    canvasCtx.arc(\r\n                        landmark.x * videoWidth,\r\n                        landmark.y * videoHeight,\r\n                        5,\r\n                        0,\r\n                        2 * Math.PI\r\n                    );\r\n                    canvasCtx.fillStyle = '#FFFFFF';\r\n                    canvasCtx.fill();\r\n                    canvasCtx.strokeStyle = '#000000';\r\n                    canvasCtx.stroke();\r\n                }\r\n            });\r\n\r\n            canvasCtx.restore();\r\n        }\r\n    }, [selectedPose]);\r\n\r\n    useEffect(() => {\r\n        let pose = null;\r\n        let camera = null;\r\n\r\n        const initializePose = async () => {\r\n            try {\r\n                pose = new Pose({\r\n                    locateFile: (file) => {\r\n                        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\r\n                    }\r\n                });\r\n\r\n                pose.setOptions({\r\n                    modelComplexity: 1,\r\n                    smoothLandmarks: true,\r\n                    enableSegmentation: false,\r\n                    smoothSegmentation: false,\r\n                    minDetectionConfidence: 0.5,\r\n                    minTrackingConfidence: 0.5\r\n                });\r\n\r\n                pose.onResults(onResults);\r\n\r\n                if (webcamRef.current && webcamRef.current.video) {\r\n                    camera = new Camera(webcamRef.current.video, {\r\n                        onFrame: async () => {\r\n                            if (webcamRef.current && webcamRef.current.video) {\r\n                                await pose.send({ image: webcamRef.current.video });\r\n                            }\r\n                        },\r\n                        width: 640,\r\n                        height: 480\r\n                    });\r\n\r\n                    camera.start();\r\n                    setIsLoading(false);\r\n                }\r\n            } catch (err) {\r\n                console.error('Error initializing pose detection:', err);\r\n                setError('Failed to initialize pose detection. Please try refreshing the page.');\r\n                setIsLoading(false);\r\n            }\r\n        };\r\n\r\n        initializePose();\r\n\r\n        return () => {\r\n            if (camera) {\r\n                camera.stop();\r\n            }\r\n            if (pose) {\r\n                pose.close();\r\n            }\r\n        };\r\n    }, [onResults]);\r\n\r\n    useEffect(() => {\r\n        // Initialize WebSocket connection\r\n        const ws = new WebSocket('ws://localhost:8000/ws/pose-feedback');\r\n\r\n        ws.onopen = () => {\r\n            console.log('Connected to feedback server');\r\n            setWsConnection(ws);\r\n        };\r\n\r\n        ws.onmessage = (event) => {\r\n            setPoseFeedback(event.data);\r\n        };\r\n\r\n        ws.onerror = (error) => {\r\n            console.error('WebSocket error:', error);\r\n        };\r\n\r\n        return () => {\r\n            if (ws) {\r\n                ws.close();\r\n            }\r\n        };\r\n    }, []);\r\n\r\n    // Send pose data to backend when accuracy updates\r\n    useEffect(() => {\r\n        if (wsConnection && selectedPose && Object.keys(segmentAccuracies).length > 0) {\r\n            const poseData = {\r\n                pose_name: selectedPose.name || 'unknown pose',\r\n                overall_accuracy: poseAccuracy,\r\n                segment_accuracies: segmentAccuracies\r\n            };\r\n            wsConnection.send(JSON.stringify(poseData));\r\n        }\r\n    }, [poseAccuracy, segmentAccuracies, selectedPose, wsConnection]);\r\n\r\n    // Load initial pose based on user preferences\r\n    useEffect(() => {\r\n        const loadPose = async () => {\r\n            try {\r\n                // You would typically load this from your backend or a static file\r\n                const response = await fetch('/pose_results/tree-pose_pose.json');\r\n                const poseData = await response.json();\r\n                setSelectedPose(poseData);\r\n            } catch (err) {\r\n                console.error('Error loading pose data:', err);\r\n                setError('Failed to load pose data. Please try refreshing the page.');\r\n            }\r\n        };\r\n\r\n        if (userPreferences) {\r\n            loadPose();\r\n        }\r\n    }, [userPreferences]);\r\n\r\n    return (\r\n        <div className=\"pose-tracker\">\r\n            {isLoading && (\r\n                <div className=\"loading\">\r\n                    <p>Loading pose detector... Please wait a moment.</p>\r\n                    <p style={{ fontSize: '0.9em', color: '#666' }}>\r\n                        This may take a few seconds to initialize.\r\n                    </p>\r\n                </div>\r\n            )}\r\n            {error && (\r\n                <div className=\"error\">\r\n                    <p>{error}</p>\r\n                    <button\r\n                        onClick={() => window.location.reload()}\r\n                        className=\"retry-button\"\r\n                    >\r\n                        Retry\r\n                    </button>\r\n                </div>\r\n            )}\r\n            <div className=\"camera-container\">\r\n                <Webcam\r\n                    ref={webcamRef}\r\n                    className=\"webcam\"\r\n                    mirrored={true}\r\n                    videoConstraints={videoConstraints}\r\n                />\r\n                <canvas ref={canvasRef} className=\"pose-canvas\" />\r\n                {selectedPose && selectedPose.landmarks && Object.keys(segmentAccuracies).length > 0 && (\r\n                    <div className=\"accuracy-display\">\r\n                        <div className=\"accuracy-overall\">\r\n                            Overall Accuracy: {poseAccuracy}%\r\n                        </div>\r\n                        <div className=\"accuracy-segments\">\r\n                            {Object.entries(segmentAccuracies).map(([segment, data]) => (\r\n                                <div key={segment} className=\"accuracy-segment\">\r\n                                    {segment.charAt(0).toUpperCase() + segment.slice(1)}: {Math.round(data.accuracy)}%\r\n                                </div>\r\n                            ))}\r\n                        </div>\r\n                        {poseFeedback && (\r\n                            <div className=\"pose-feedback\">\r\n                                <div className=\"feedback-title\">Instructor Feedback:</div>\r\n                                {poseFeedback}\r\n                            </div>\r\n                        )}\r\n                    </div>\r\n                )}\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default PoseTracker;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}