{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Quant\\\\Documents\\\\Programming\\\\Projects\\\\Hackathon\\\\MakeUofT\\\\frontend\\\\src\\\\components\\\\PoseTracker.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport Webcam from 'react-webcam';\nimport { Camera } from '@mediapipe/camera_utils';\nimport { Pose } from '@mediapipe/pose';\nimport './PoseTracker.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst PoseTracker = ({\n  selectedPose\n}) => {\n  _s();\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n  const poseRef = useRef(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [poseAccuracy, setPoseAccuracy] = useState(0);\n  const [segmentAccuracies, setSegmentAccuracies] = useState({});\n  const videoConstraints = {\n    width: 640,\n    height: 480,\n    facingMode: 'user'\n  };\n  const calculatePoseAccuracy = (userLandmarks, targetPose) => {\n    if (!targetPose || !userLandmarks) return {\n      total: 0,\n      segments: {}\n    };\n\n    // Define body segments with their corresponding landmark indices\n    const bodySegments = {\n      head: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      upperBody: [11, 12, 13, 14, 15, 16],\n      // shoulders, elbows, wrists\n      torso: [11, 12, 23, 24],\n      // shoulders to hips\n      lowerBody: [23, 24, 25, 26, 27, 28] // hips to ankles\n    };\n\n    // Define key points that must be visible for each segment\n    const requiredPoints = {\n      head: [0, 1, 4],\n      // Nose and eyes\n      upperBody: [11, 12],\n      // Shoulders\n      torso: [11, 12, 23, 24],\n      // Shoulders and hips\n      lowerBody: [23, 24, 25, 26] // Hips and knees\n    };\n    let segmentAccuracies = {};\n    let visibleSegments = 0;\n\n    // Calculate accuracy for each body segment\n    for (const [segment, points] of Object.entries(bodySegments)) {\n      // First check if required points are visible enough\n      const requiredVisible = requiredPoints[segment].every(index => userLandmarks[index].visibility > 0.5);\n      if (!requiredVisible) {\n        continue; // Skip this segment if required points aren't visible\n      }\n      let segmentTotal = 0;\n      let segmentPoints = 0;\n      let visiblePoints = 0;\n\n      // Calculate average position of visible points in the target pose\n      let targetCenterX = 0;\n      let targetCenterY = 0;\n      let visibleTargetPoints = 0;\n      points.forEach(index => {\n        const targetLandmark = targetPose.landmarks[index];\n        const userLandmark = userLandmarks[index];\n        if (targetLandmark.visibility > 0.5 && userLandmark.visibility > 0.5) {\n          targetCenterX += targetLandmark.x;\n          targetCenterY += targetLandmark.y;\n          visibleTargetPoints++;\n        }\n      });\n      if (visibleTargetPoints < points.length * 0.5) {\n        continue; // Skip if less than 50% of points are visible\n      }\n      targetCenterX /= visibleTargetPoints;\n      targetCenterY /= visibleTargetPoints;\n\n      // Calculate accuracies for visible points\n      points.forEach(index => {\n        const userLandmark = userLandmarks[index];\n        const targetLandmark = targetPose.landmarks[index];\n        if (userLandmark.visibility > 0.5 && targetLandmark.visibility > 0.5) {\n          visiblePoints++;\n\n          // Calculate distances relative to segment center\n          const userRelativeX = userLandmark.x - targetCenterX;\n          const userRelativeY = userLandmark.y - targetCenterY;\n          const targetRelativeX = targetLandmark.x - targetCenterX;\n          const targetRelativeY = targetLandmark.y - targetCenterY;\n\n          // Calculate position difference\n          const distance = Math.sqrt(Math.pow(userRelativeX - targetRelativeX, 2) + Math.pow(userRelativeY - targetRelativeY, 2));\n\n          // Convert distance to accuracy with more lenient tolerance\n          const tolerance = 0.2;\n          const pointAccuracy = Math.max(0, 1 - distance / tolerance);\n\n          // Weight by visibility\n          const visibilityWeight = userLandmark.visibility;\n          segmentTotal += pointAccuracy * visibilityWeight;\n          segmentPoints += visibilityWeight;\n        }\n      });\n\n      // Only include segment if enough points are visible and accurate\n      if (segmentPoints > 0 && visiblePoints >= points.length * 0.5) {\n        const rawAccuracy = segmentTotal / segmentPoints * 100;\n        segmentAccuracies[segment] = {\n          accuracy: Math.min(100, Math.max(0, rawAccuracy)),\n          visibility: visiblePoints / points.length\n        };\n        visibleSegments++;\n      }\n    }\n\n    // Calculate overall accuracy\n    if (visibleSegments === 0) return {\n      total: 0,\n      segments: {}\n    };\n    let totalAccuracy = 0;\n    let totalWeight = 0;\n\n    // Weight segments differently\n    const segmentWeights = {\n      head: 1,\n      upperBody: 1.2,\n      torso: 1.2,\n      lowerBody: 1\n    };\n    for (const [segment, data] of Object.entries(segmentAccuracies)) {\n      const weight = segmentWeights[segment] || 1;\n      totalAccuracy += data.accuracy * weight;\n      totalWeight += weight;\n    }\n    return {\n      total: Math.round(totalWeight > 0 ? totalAccuracy / totalWeight : 0),\n      segments: segmentAccuracies\n    };\n  };\n  const onResults = useCallback(results => {\n    if (!canvasRef.current || !results.poseLandmarks) return;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext('2d');\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight;\n\n    // Set canvas dimensions to match video\n    canvasElement.width = videoWidth;\n    canvasElement.height = videoHeight;\n\n    // Calculate pose accuracy if we have a selected pose\n    if (selectedPose && selectedPose.landmarks) {\n      const accuracyData = calculatePoseAccuracy(results.poseLandmarks, selectedPose);\n      setPoseAccuracy(accuracyData.total);\n      setSegmentAccuracies(accuracyData.segments);\n    }\n\n    // Clear canvas\n    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n    // Draw pose landmarks\n    if (results.poseLandmarks) {\n      // Draw the pose landmarks\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n      // Mirror the canvas context\n      canvasCtx.scale(-1, 1);\n      canvasCtx.translate(-videoWidth, 0);\n\n      // Draw connectors\n      canvasCtx.lineWidth = 3;\n\n      // Draw pose connections\n      function drawConnection(landmarks, start, end, color) {\n        const startPoint = landmarks[start];\n        const endPoint = landmarks[end];\n        if (startPoint.visibility > 0.5 && endPoint.visibility > 0.5) {\n          canvasCtx.beginPath();\n          canvasCtx.moveTo(startPoint.x * videoWidth, startPoint.y * videoHeight);\n          canvasCtx.lineTo(endPoint.x * videoWidth, endPoint.y * videoHeight);\n          canvasCtx.strokeStyle = color;\n          canvasCtx.stroke();\n        }\n      }\n      const landmarks = results.poseLandmarks;\n\n      // Draw body parts with different colors\n      // Upper body (green)\n      const upperBodyColor = '#00FF00';\n      drawConnection(landmarks, 11, 12, upperBodyColor); // shoulders\n      drawConnection(landmarks, 11, 13, upperBodyColor); // left upper arm\n      drawConnection(landmarks, 13, 15, upperBodyColor); // left lower arm\n      drawConnection(landmarks, 12, 14, upperBodyColor); // right upper arm\n      drawConnection(landmarks, 14, 16, upperBodyColor); // right lower arm\n\n      // Head (red)\n      const headColor = '#FF0000';\n      drawConnection(landmarks, 0, 1, headColor);\n      drawConnection(landmarks, 1, 2, headColor);\n      drawConnection(landmarks, 2, 3, headColor);\n      drawConnection(landmarks, 3, 7, headColor);\n      drawConnection(landmarks, 0, 4, headColor);\n      drawConnection(landmarks, 4, 5, headColor);\n      drawConnection(landmarks, 5, 6, headColor);\n      drawConnection(landmarks, 6, 8, headColor);\n\n      // Torso (blue)\n      const torsoColor = '#0000FF';\n      drawConnection(landmarks, 11, 23, torsoColor); // left shoulder to hip\n      drawConnection(landmarks, 12, 24, torsoColor); // right shoulder to hip\n      drawConnection(landmarks, 23, 24, torsoColor); // hips\n\n      // Lower body (yellow)\n      const lowerBodyColor = '#FFFF00';\n      drawConnection(landmarks, 23, 25, lowerBodyColor); // left hip to knee\n      drawConnection(landmarks, 25, 27, lowerBodyColor); // left knee to ankle\n      drawConnection(landmarks, 24, 26, lowerBodyColor); // right hip to knee\n      drawConnection(landmarks, 26, 28, lowerBodyColor); // right knee to ankle\n\n      // Draw landmarks\n      landmarks.forEach((landmark, index) => {\n        if (landmark.visibility > 0.5) {\n          canvasCtx.beginPath();\n          canvasCtx.arc(landmark.x * videoWidth, landmark.y * videoHeight, 5, 0, 2 * Math.PI);\n          canvasCtx.fillStyle = '#FFFFFF';\n          canvasCtx.fill();\n          canvasCtx.strokeStyle = '#000000';\n          canvasCtx.stroke();\n        }\n      });\n      canvasCtx.restore();\n    }\n  }, [selectedPose]);\n  useEffect(() => {\n    let pose = null;\n    let camera = null;\n    const initializePose = async () => {\n      try {\n        pose = new Pose({\n          locateFile: file => {\n            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n          }\n        });\n        pose.setOptions({\n          modelComplexity: 1,\n          smoothLandmarks: true,\n          enableSegmentation: false,\n          smoothSegmentation: false,\n          minDetectionConfidence: 0.5,\n          minTrackingConfidence: 0.5\n        });\n        pose.onResults(onResults);\n        if (webcamRef.current && webcamRef.current.video) {\n          camera = new Camera(webcamRef.current.video, {\n            onFrame: async () => {\n              if (webcamRef.current && webcamRef.current.video) {\n                await pose.send({\n                  image: webcamRef.current.video\n                });\n              }\n            },\n            width: 640,\n            height: 480\n          });\n          camera.start();\n          setIsLoading(false);\n        }\n      } catch (err) {\n        console.error('Error initializing pose detection:', err);\n        setError('Failed to initialize pose detection. Please try refreshing the page.');\n        setIsLoading(false);\n      }\n    };\n    initializePose();\n    return () => {\n      if (camera) {\n        camera.stop();\n      }\n      if (pose) {\n        pose.close();\n      }\n    };\n  }, [onResults]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"pose-tracker\",\n    children: [isLoading && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"loading\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Loading pose detector... Please wait a moment.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 316,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        style: {\n          fontSize: '0.9em',\n          color: '#666'\n        },\n        children: \"This may take a few seconds to initialize.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 317,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 315,\n      columnNumber: 17\n    }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"error\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: error\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 324,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => window.location.reload(),\n        style: {\n          marginTop: '10px',\n          padding: '8px 16px',\n          backgroundColor: '#4CAF50',\n          color: 'white',\n          border: 'none',\n          borderRadius: '4px',\n          cursor: 'pointer'\n        },\n        children: \"Retry\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 325,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 323,\n      columnNumber: 17\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"camera-container\",\n      children: [/*#__PURE__*/_jsxDEV(Webcam, {\n        ref: webcamRef,\n        className: \"webcam\",\n        mirrored: true,\n        videoConstraints: videoConstraints\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 342,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        className: \"pose-canvas\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 348,\n        columnNumber: 17\n      }, this), selectedPose && selectedPose.landmarks && Object.keys(segmentAccuracies).length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"accuracy-display\",\n        style: {\n          position: 'absolute',\n          top: '20px',\n          left: '20px',\n          background: 'rgba(0, 0, 0, 0.7)',\n          color: 'white',\n          padding: '15px',\n          borderRadius: '5px',\n          fontSize: '1.1em',\n          zIndex: 1000\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            marginBottom: '10px',\n            fontWeight: 'bold'\n          },\n          children: [\"Overall Accuracy: \", poseAccuracy, \"%\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 361,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontSize: '0.9em'\n          },\n          children: Object.entries(segmentAccuracies).map(([segment, data]) => /*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              marginBottom: '5px'\n            },\n            children: [segment.charAt(0).toUpperCase() + segment.slice(1), \": \", Math.round(data.accuracy), \"%\"]\n          }, segment, true, {\n            fileName: _jsxFileName,\n            lineNumber: 366,\n            columnNumber: 33\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 364,\n          columnNumber: 25\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 350,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 341,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 313,\n    columnNumber: 9\n  }, this);\n};\n_s(PoseTracker, \"8mtGNSLsT2ntv7fseDpd769CZ70=\");\n_c = PoseTracker;\nexport default PoseTracker;\nvar _c;\n$RefreshReg$(_c, \"PoseTracker\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","Webcam","Camera","Pose","jsxDEV","_jsxDEV","PoseTracker","selectedPose","_s","webcamRef","canvasRef","poseRef","isLoading","setIsLoading","error","setError","poseAccuracy","setPoseAccuracy","segmentAccuracies","setSegmentAccuracies","videoConstraints","width","height","facingMode","calculatePoseAccuracy","userLandmarks","targetPose","total","segments","bodySegments","head","upperBody","torso","lowerBody","requiredPoints","visibleSegments","segment","points","Object","entries","requiredVisible","every","index","visibility","segmentTotal","segmentPoints","visiblePoints","targetCenterX","targetCenterY","visibleTargetPoints","forEach","targetLandmark","landmarks","userLandmark","x","y","length","userRelativeX","userRelativeY","targetRelativeX","targetRelativeY","distance","Math","sqrt","pow","tolerance","pointAccuracy","max","visibilityWeight","rawAccuracy","accuracy","min","totalAccuracy","totalWeight","segmentWeights","data","weight","round","onResults","results","current","poseLandmarks","canvasElement","canvasCtx","getContext","videoWidth","video","videoHeight","accuracyData","clearRect","save","scale","translate","lineWidth","drawConnection","start","end","color","startPoint","endPoint","beginPath","moveTo","lineTo","strokeStyle","stroke","upperBodyColor","headColor","torsoColor","lowerBodyColor","landmark","arc","PI","fillStyle","fill","restore","pose","camera","initializePose","locateFile","file","setOptions","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","minDetectionConfidence","minTrackingConfidence","onFrame","send","image","err","console","stop","close","className","children","fileName","_jsxFileName","lineNumber","columnNumber","style","fontSize","onClick","window","location","reload","marginTop","padding","backgroundColor","border","borderRadius","cursor","ref","mirrored","keys","position","top","left","background","zIndex","marginBottom","fontWeight","map","charAt","toUpperCase","slice","_c","$RefreshReg$"],"sources":["C:/Users/Quant/Documents/Programming/Projects/Hackathon/MakeUofT/frontend/src/components/PoseTracker.js"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\nimport Webcam from 'react-webcam';\nimport { Camera } from '@mediapipe/camera_utils';\nimport { Pose } from '@mediapipe/pose';\nimport './PoseTracker.css';\n\nconst PoseTracker = ({ selectedPose }) => {\n    const webcamRef = useRef(null);\n    const canvasRef = useRef(null);\n    const poseRef = useRef(null);\n    const [isLoading, setIsLoading] = useState(true);\n    const [error, setError] = useState(null);\n    const [poseAccuracy, setPoseAccuracy] = useState(0);\n    const [segmentAccuracies, setSegmentAccuracies] = useState({});\n\n    const videoConstraints = {\n        width: 640,\n        height: 480,\n        facingMode: 'user',\n    };\n\n    const calculatePoseAccuracy = (userLandmarks, targetPose) => {\n        if (!targetPose || !userLandmarks) return { total: 0, segments: {} };\n\n        // Define body segments with their corresponding landmark indices\n        const bodySegments = {\n            head: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n            upperBody: [11, 12, 13, 14, 15, 16], // shoulders, elbows, wrists\n            torso: [11, 12, 23, 24], // shoulders to hips\n            lowerBody: [23, 24, 25, 26, 27, 28] // hips to ankles\n        };\n\n        // Define key points that must be visible for each segment\n        const requiredPoints = {\n            head: [0, 1, 4], // Nose and eyes\n            upperBody: [11, 12], // Shoulders\n            torso: [11, 12, 23, 24], // Shoulders and hips\n            lowerBody: [23, 24, 25, 26] // Hips and knees\n        };\n\n        let segmentAccuracies = {};\n        let visibleSegments = 0;\n\n        // Calculate accuracy for each body segment\n        for (const [segment, points] of Object.entries(bodySegments)) {\n            // First check if required points are visible enough\n            const requiredVisible = requiredPoints[segment].every(index =>\n                userLandmarks[index].visibility > 0.5\n            );\n\n            if (!requiredVisible) {\n                continue; // Skip this segment if required points aren't visible\n            }\n\n            let segmentTotal = 0;\n            let segmentPoints = 0;\n            let visiblePoints = 0;\n\n            // Calculate average position of visible points in the target pose\n            let targetCenterX = 0;\n            let targetCenterY = 0;\n            let visibleTargetPoints = 0;\n\n            points.forEach(index => {\n                const targetLandmark = targetPose.landmarks[index];\n                const userLandmark = userLandmarks[index];\n\n                if (targetLandmark.visibility > 0.5 && userLandmark.visibility > 0.5) {\n                    targetCenterX += targetLandmark.x;\n                    targetCenterY += targetLandmark.y;\n                    visibleTargetPoints++;\n                }\n            });\n\n            if (visibleTargetPoints < points.length * 0.5) {\n                continue; // Skip if less than 50% of points are visible\n            }\n\n            targetCenterX /= visibleTargetPoints;\n            targetCenterY /= visibleTargetPoints;\n\n            // Calculate accuracies for visible points\n            points.forEach(index => {\n                const userLandmark = userLandmarks[index];\n                const targetLandmark = targetPose.landmarks[index];\n\n                if (userLandmark.visibility > 0.5 && targetLandmark.visibility > 0.5) {\n                    visiblePoints++;\n\n                    // Calculate distances relative to segment center\n                    const userRelativeX = userLandmark.x - targetCenterX;\n                    const userRelativeY = userLandmark.y - targetCenterY;\n                    const targetRelativeX = targetLandmark.x - targetCenterX;\n                    const targetRelativeY = targetLandmark.y - targetCenterY;\n\n                    // Calculate position difference\n                    const distance = Math.sqrt(\n                        Math.pow(userRelativeX - targetRelativeX, 2) +\n                        Math.pow(userRelativeY - targetRelativeY, 2)\n                    );\n\n                    // Convert distance to accuracy with more lenient tolerance\n                    const tolerance = 0.2;\n                    const pointAccuracy = Math.max(0, 1 - (distance / tolerance));\n\n                    // Weight by visibility\n                    const visibilityWeight = userLandmark.visibility;\n                    segmentTotal += pointAccuracy * visibilityWeight;\n                    segmentPoints += visibilityWeight;\n                }\n            });\n\n            // Only include segment if enough points are visible and accurate\n            if (segmentPoints > 0 && visiblePoints >= points.length * 0.5) {\n                const rawAccuracy = (segmentTotal / segmentPoints) * 100;\n                segmentAccuracies[segment] = {\n                    accuracy: Math.min(100, Math.max(0, rawAccuracy)),\n                    visibility: visiblePoints / points.length\n                };\n                visibleSegments++;\n            }\n        }\n\n        // Calculate overall accuracy\n        if (visibleSegments === 0) return { total: 0, segments: {} };\n\n        let totalAccuracy = 0;\n        let totalWeight = 0;\n\n        // Weight segments differently\n        const segmentWeights = {\n            head: 1,\n            upperBody: 1.2,\n            torso: 1.2,\n            lowerBody: 1\n        };\n\n        for (const [segment, data] of Object.entries(segmentAccuracies)) {\n            const weight = segmentWeights[segment] || 1;\n            totalAccuracy += data.accuracy * weight;\n            totalWeight += weight;\n        }\n\n        return {\n            total: Math.round(totalWeight > 0 ? totalAccuracy / totalWeight : 0),\n            segments: segmentAccuracies\n        };\n    };\n\n    const onResults = useCallback((results) => {\n        if (!canvasRef.current || !results.poseLandmarks) return;\n\n        const canvasElement = canvasRef.current;\n        const canvasCtx = canvasElement.getContext('2d');\n        const videoWidth = webcamRef.current.video.videoWidth;\n        const videoHeight = webcamRef.current.video.videoHeight;\n\n        // Set canvas dimensions to match video\n        canvasElement.width = videoWidth;\n        canvasElement.height = videoHeight;\n\n        // Calculate pose accuracy if we have a selected pose\n        if (selectedPose && selectedPose.landmarks) {\n            const accuracyData = calculatePoseAccuracy(results.poseLandmarks, selectedPose);\n            setPoseAccuracy(accuracyData.total);\n            setSegmentAccuracies(accuracyData.segments);\n        }\n\n        // Clear canvas\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n        // Draw pose landmarks\n        if (results.poseLandmarks) {\n            // Draw the pose landmarks\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n            // Mirror the canvas context\n            canvasCtx.scale(-1, 1);\n            canvasCtx.translate(-videoWidth, 0);\n\n            // Draw connectors\n            canvasCtx.lineWidth = 3;\n\n            // Draw pose connections\n            function drawConnection(landmarks, start, end, color) {\n                const startPoint = landmarks[start];\n                const endPoint = landmarks[end];\n\n                if (startPoint.visibility > 0.5 && endPoint.visibility > 0.5) {\n                    canvasCtx.beginPath();\n                    canvasCtx.moveTo(startPoint.x * videoWidth, startPoint.y * videoHeight);\n                    canvasCtx.lineTo(endPoint.x * videoWidth, endPoint.y * videoHeight);\n                    canvasCtx.strokeStyle = color;\n                    canvasCtx.stroke();\n                }\n            }\n\n            const landmarks = results.poseLandmarks;\n\n            // Draw body parts with different colors\n            // Upper body (green)\n            const upperBodyColor = '#00FF00';\n            drawConnection(landmarks, 11, 12, upperBodyColor); // shoulders\n            drawConnection(landmarks, 11, 13, upperBodyColor); // left upper arm\n            drawConnection(landmarks, 13, 15, upperBodyColor); // left lower arm\n            drawConnection(landmarks, 12, 14, upperBodyColor); // right upper arm\n            drawConnection(landmarks, 14, 16, upperBodyColor); // right lower arm\n\n            // Head (red)\n            const headColor = '#FF0000';\n            drawConnection(landmarks, 0, 1, headColor);\n            drawConnection(landmarks, 1, 2, headColor);\n            drawConnection(landmarks, 2, 3, headColor);\n            drawConnection(landmarks, 3, 7, headColor);\n            drawConnection(landmarks, 0, 4, headColor);\n            drawConnection(landmarks, 4, 5, headColor);\n            drawConnection(landmarks, 5, 6, headColor);\n            drawConnection(landmarks, 6, 8, headColor);\n\n            // Torso (blue)\n            const torsoColor = '#0000FF';\n            drawConnection(landmarks, 11, 23, torsoColor); // left shoulder to hip\n            drawConnection(landmarks, 12, 24, torsoColor); // right shoulder to hip\n            drawConnection(landmarks, 23, 24, torsoColor); // hips\n\n            // Lower body (yellow)\n            const lowerBodyColor = '#FFFF00';\n            drawConnection(landmarks, 23, 25, lowerBodyColor); // left hip to knee\n            drawConnection(landmarks, 25, 27, lowerBodyColor); // left knee to ankle\n            drawConnection(landmarks, 24, 26, lowerBodyColor); // right hip to knee\n            drawConnection(landmarks, 26, 28, lowerBodyColor); // right knee to ankle\n\n            // Draw landmarks\n            landmarks.forEach((landmark, index) => {\n                if (landmark.visibility > 0.5) {\n                    canvasCtx.beginPath();\n                    canvasCtx.arc(\n                        landmark.x * videoWidth,\n                        landmark.y * videoHeight,\n                        5,\n                        0,\n                        2 * Math.PI\n                    );\n                    canvasCtx.fillStyle = '#FFFFFF';\n                    canvasCtx.fill();\n                    canvasCtx.strokeStyle = '#000000';\n                    canvasCtx.stroke();\n                }\n            });\n\n            canvasCtx.restore();\n        }\n    }, [selectedPose]);\n\n    useEffect(() => {\n        let pose = null;\n        let camera = null;\n\n        const initializePose = async () => {\n            try {\n                pose = new Pose({\n                    locateFile: (file) => {\n                        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n                    }\n                });\n\n                pose.setOptions({\n                    modelComplexity: 1,\n                    smoothLandmarks: true,\n                    enableSegmentation: false,\n                    smoothSegmentation: false,\n                    minDetectionConfidence: 0.5,\n                    minTrackingConfidence: 0.5\n                });\n\n                pose.onResults(onResults);\n\n                if (webcamRef.current && webcamRef.current.video) {\n                    camera = new Camera(webcamRef.current.video, {\n                        onFrame: async () => {\n                            if (webcamRef.current && webcamRef.current.video) {\n                                await pose.send({ image: webcamRef.current.video });\n                            }\n                        },\n                        width: 640,\n                        height: 480\n                    });\n\n                    camera.start();\n                    setIsLoading(false);\n                }\n            } catch (err) {\n                console.error('Error initializing pose detection:', err);\n                setError('Failed to initialize pose detection. Please try refreshing the page.');\n                setIsLoading(false);\n            }\n        };\n\n        initializePose();\n\n        return () => {\n            if (camera) {\n                camera.stop();\n            }\n            if (pose) {\n                pose.close();\n            }\n        };\n    }, [onResults]);\n\n    return (\n        <div className=\"pose-tracker\">\n            {isLoading && (\n                <div className=\"loading\">\n                    <p>Loading pose detector... Please wait a moment.</p>\n                    <p style={{ fontSize: '0.9em', color: '#666' }}>\n                        This may take a few seconds to initialize.\n                    </p>\n                </div>\n            )}\n            {error && (\n                <div className=\"error\">\n                    <p>{error}</p>\n                    <button\n                        onClick={() => window.location.reload()}\n                        style={{\n                            marginTop: '10px',\n                            padding: '8px 16px',\n                            backgroundColor: '#4CAF50',\n                            color: 'white',\n                            border: 'none',\n                            borderRadius: '4px',\n                            cursor: 'pointer',\n                        }}\n                    >\n                        Retry\n                    </button>\n                </div>\n            )}\n            <div className=\"camera-container\">\n                <Webcam\n                    ref={webcamRef}\n                    className=\"webcam\"\n                    mirrored={true}\n                    videoConstraints={videoConstraints}\n                />\n                <canvas ref={canvasRef} className=\"pose-canvas\" />\n                {selectedPose && selectedPose.landmarks && Object.keys(segmentAccuracies).length > 0 && (\n                    <div className=\"accuracy-display\" style={{\n                        position: 'absolute',\n                        top: '20px',\n                        left: '20px',\n                        background: 'rgba(0, 0, 0, 0.7)',\n                        color: 'white',\n                        padding: '15px',\n                        borderRadius: '5px',\n                        fontSize: '1.1em',\n                        zIndex: 1000\n                    }}>\n                        <div style={{ marginBottom: '10px', fontWeight: 'bold' }}>\n                            Overall Accuracy: {poseAccuracy}%\n                        </div>\n                        <div style={{ fontSize: '0.9em' }}>\n                            {Object.entries(segmentAccuracies).map(([segment, data]) => (\n                                <div key={segment} style={{ marginBottom: '5px' }}>\n                                    {segment.charAt(0).toUpperCase() + segment.slice(1)}: {Math.round(data.accuracy)}%\n                                </div>\n                            ))}\n                        </div>\n                    </div>\n                )}\n            </div>\n        </div>\n    );\n};\n\nexport default PoseTracker;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}