{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Quant\\\\Documents\\\\Programming\\\\Projects\\\\Hackathon\\\\MakeUofT\\\\frontend\\\\src\\\\components\\\\PoseTracker.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport Webcam from 'react-webcam';\nimport { Camera } from '@mediapipe/camera_utils';\nimport { Pose } from '@mediapipe/pose';\nimport './PoseTracker.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst PoseTracker = ({\n  selectedPose\n}) => {\n  _s();\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n  const poseRef = useRef(null);\n  const cameraRef = useRef(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [poseAccuracy, setPoseAccuracy] = useState(0);\n  const [segmentAccuracies, setSegmentAccuracies] = useState({});\n  const [isActive, setIsActive] = useState(true);\n  const videoConstraints = {\n    width: 640,\n    height: 480,\n    facingMode: 'user'\n  };\n  const calculatePoseAccuracy = (userLandmarks, targetPose) => {\n    if (!targetPose || !userLandmarks) {\n      console.log('Missing data:', {\n        targetPose: !!targetPose,\n        userLandmarks: !!userLandmarks\n      });\n      return {\n        total: 0,\n        segments: {}\n      };\n    }\n\n    // Calculate scale factors based on body size in frame\n    const calculateBodyScale = landmarks => {\n      // Try different reference points for scaling based on what's visible\n      const scalePoints = [\n      // Shoulders width\n      {\n        points: [11, 12],\n        type: 'width'\n      },\n      // Face width\n      {\n        points: [7, 8],\n        type: 'width'\n      },\n      // Upper body height (neck to hips)\n      {\n        points: [0, 23],\n        type: 'height'\n      },\n      // Arm length\n      {\n        points: [11, 15],\n        type: 'height'\n      }];\n      for (const {\n        points,\n        type\n      } of scalePoints) {\n        const point1 = landmarks[points[0]];\n        const point2 = landmarks[points[1]];\n        if (point1 && point2 && point1.visibility > 0.5 && point2.visibility > 0.5) {\n          const distance = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n          return {\n            [type]: distance,\n            width: type === 'width' ? distance : null,\n            height: type === 'height' ? distance : null\n          };\n        }\n      }\n\n      // If no reference points are found, return a default scale\n      return {\n        width: 1,\n        height: 1\n      };\n    };\n    const userScale = calculateBodyScale(userLandmarks);\n    const targetScale = calculateBodyScale(targetPose.landmarks);\n\n    // Calculate scale ratio between user and target pose\n    const scaleRatio = {\n      height: targetScale.height && userScale.height ? targetScale.height / userScale.height : 1,\n      width: targetScale.width && userScale.width ? targetScale.width / userScale.width : 1\n    };\n\n    // Define body segments with their corresponding landmark indices\n    const bodySegments = {\n      head: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      upperBody: [11, 12, 13, 14, 15, 16],\n      // shoulders, elbows, wrists\n      torso: [11, 12, 23, 24],\n      // shoulders to hips\n      lowerBody: [23, 24, 25, 26, 27, 28] // hips to ankles\n    };\n    let segmentAccuracies = {};\n\n    // Calculate accuracy for each body segment\n    for (const [segmentName, points] of Object.entries(bodySegments)) {\n      let segmentTotal = 0;\n      let segmentPoints = 0;\n      let visiblePoints = 0;\n      let totalVisibilityScore = 0;\n      points.forEach(index => {\n        const userLandmark = userLandmarks[index];\n        const targetLandmark = targetPose.landmarks[index];\n        if (!userLandmark || !targetLandmark) {\n          return;\n        }\n\n        // Add to visibility score even if below threshold\n        totalVisibilityScore += userLandmark.visibility;\n\n        // More lenient visibility threshold\n        if (userLandmark.visibility > 0.05 && targetLandmark.visibility > 0.05) {\n          visiblePoints++;\n\n          // Scale the user's coordinates based on the calculated ratio\n          const scaledUserX = userLandmark.x * scaleRatio.width;\n          const scaledUserY = userLandmark.y * scaleRatio.height;\n\n          // Calculate Euclidean distance using scaled coordinates\n          const distance = Math.sqrt(Math.pow(scaledUserX - targetLandmark.x, 2) + Math.pow(scaledUserY - targetLandmark.y, 2));\n\n          // Adjust tolerance based on the segment and visibility\n          let tolerance = 0.2; // Increased base tolerance\n          if (segmentName === 'head') {\n            tolerance = 0.15;\n          } else if (segmentName === 'lowerBody') {\n            tolerance = 0.25;\n          }\n\n          // Make tolerance more forgiving for partially visible points\n          tolerance = tolerance * (1 + (1 - userLandmark.visibility) * 0.5);\n\n          // Convert distance to accuracy (closer = higher accuracy)\n          const pointAccuracy = Math.max(0, 1 - distance / tolerance);\n\n          // Weight the accuracy by visibility\n          const weightedAccuracy = pointAccuracy * Math.min(userLandmark.visibility, targetLandmark.visibility);\n          segmentTotal += weightedAccuracy;\n          segmentPoints++;\n        }\n      });\n\n      // More lenient visibility threshold for segments\n      const visibilityThreshold = 0.05; // Lowered threshold significantly\n      const averageVisibility = totalVisibilityScore / points.length;\n      const visibilityPercentage = visiblePoints / points.length;\n\n      // Include segment if it has any visible points\n      if (visibilityPercentage > visibilityThreshold && segmentPoints > 0) {\n        const segmentAccuracy = segmentTotal / segmentPoints * 100;\n        segmentAccuracies[segmentName] = {\n          accuracy: segmentAccuracy * Math.min(1, averageVisibility * 2),\n          visibility: visibilityPercentage\n        };\n      }\n    }\n\n    // Calculate weighted average of visible segment accuracies\n    let totalAccuracy = 0;\n    let totalWeight = 0;\n    for (const [, data] of Object.entries(segmentAccuracies)) {\n      const weight = data.visibility;\n      totalAccuracy += data.accuracy * weight;\n      totalWeight += weight;\n    }\n    const result = {\n      total: Math.round(totalWeight > 0 ? totalAccuracy / totalWeight : 0),\n      segments: segmentAccuracies\n    };\n    return result;\n  };\n  const onResults = useCallback(results => {\n    if (!canvasRef.current || !results.poseLandmarks) return;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext('2d');\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight;\n\n    // Set canvas dimensions to match video\n    canvasElement.width = videoWidth;\n    canvasElement.height = videoHeight;\n\n    // Calculate pose accuracy if we have a selected pose\n    if (selectedPose) {\n      console.log('Processing frame with selected pose:', selectedPose);\n      const accuracyData = calculatePoseAccuracy(results.poseLandmarks, selectedPose);\n      setPoseAccuracy(accuracyData.total);\n      setSegmentAccuracies(accuracyData.segments);\n    } else {\n      console.log('No pose selected');\n    }\n\n    // Clear canvas\n    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n    // Draw pose landmarks\n    if (results.poseLandmarks) {\n      // Draw the pose landmarks\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n      // Mirror the canvas context\n      canvasCtx.scale(-1, 1);\n      canvasCtx.translate(-videoWidth, 0);\n\n      // Draw connectors\n      canvasCtx.lineWidth = 3;\n\n      // Draw pose connections\n      function drawConnection(landmarks, start, end, color) {\n        const startPoint = landmarks[start];\n        const endPoint = landmarks[end];\n        if (startPoint.visibility > 0.5 && endPoint.visibility > 0.5) {\n          canvasCtx.beginPath();\n          canvasCtx.moveTo(startPoint.x * videoWidth, startPoint.y * videoHeight);\n          canvasCtx.lineTo(endPoint.x * videoWidth, endPoint.y * videoHeight);\n          canvasCtx.strokeStyle = color;\n          canvasCtx.stroke();\n        }\n      }\n      const landmarks = results.poseLandmarks;\n\n      // Draw body parts with different colors\n      // Upper body (green)\n      const upperBodyColor = '#00FF00';\n      drawConnection(landmarks, 11, 12, upperBodyColor); // shoulders\n      drawConnection(landmarks, 11, 13, upperBodyColor); // left upper arm\n      drawConnection(landmarks, 13, 15, upperBodyColor); // left lower arm\n      drawConnection(landmarks, 12, 14, upperBodyColor); // right upper arm\n      drawConnection(landmarks, 14, 16, upperBodyColor); // right lower arm\n\n      // Head (red)\n      const headColor = '#FF0000';\n      drawConnection(landmarks, 0, 1, headColor);\n      drawConnection(landmarks, 1, 2, headColor);\n      drawConnection(landmarks, 2, 3, headColor);\n      drawConnection(landmarks, 3, 7, headColor);\n      drawConnection(landmarks, 0, 4, headColor);\n      drawConnection(landmarks, 4, 5, headColor);\n      drawConnection(landmarks, 5, 6, headColor);\n      drawConnection(landmarks, 6, 8, headColor);\n\n      // Torso (blue)\n      const torsoColor = '#0000FF';\n      drawConnection(landmarks, 11, 23, torsoColor); // left shoulder to hip\n      drawConnection(landmarks, 12, 24, torsoColor); // right shoulder to hip\n      drawConnection(landmarks, 23, 24, torsoColor); // hips\n\n      // Lower body (yellow)\n      const lowerBodyColor = '#FFFF00';\n      drawConnection(landmarks, 23, 25, lowerBodyColor); // left hip to knee\n      drawConnection(landmarks, 25, 27, lowerBodyColor); // left knee to ankle\n      drawConnection(landmarks, 24, 26, lowerBodyColor); // right hip to knee\n      drawConnection(landmarks, 26, 28, lowerBodyColor); // right knee to ankle\n\n      // Draw landmarks\n      landmarks.forEach((landmark, index) => {\n        if (landmark.visibility > 0.5) {\n          canvasCtx.beginPath();\n          canvasCtx.arc(landmark.x * videoWidth, landmark.y * videoHeight, 5, 0, 2 * Math.PI);\n          canvasCtx.fillStyle = '#FFFFFF';\n          canvasCtx.fill();\n          canvasCtx.strokeStyle = '#000000';\n          canvasCtx.stroke();\n        }\n      });\n      canvasCtx.restore();\n    }\n  }, [selectedPose]);\n\n  // Move initializePose outside useEffect so it can be used by handleReset\n  const initializePose = useCallback(async () => {\n    try {\n      // Clean up any existing instances\n      if (poseRef.current) {\n        poseRef.current.close();\n      }\n      if (cameraRef.current) {\n        cameraRef.current.stop();\n      }\n\n      // Create new pose instance\n      const pose = new Pose({\n        locateFile: file => {\n          return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n        }\n      });\n\n      // Store pose instance in ref\n      poseRef.current = pose;\n\n      // Configure pose options\n      await pose.setOptions({\n        modelComplexity: 1,\n        smoothLandmarks: true,\n        enableSegmentation: false,\n        smoothSegmentation: false,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n      });\n\n      // Set up pose callback\n      pose.onResults(onResults);\n\n      // Initialize camera only if component is still mounted\n      if (webcamRef.current && webcamRef.current.video) {\n        const camera = new Camera(webcamRef.current.video, {\n          onFrame: async () => {\n            if (!isActive) return;\n            try {\n              if (poseRef.current && webcamRef.current && webcamRef.current.video) {\n                await poseRef.current.send({\n                  image: webcamRef.current.video\n                });\n              }\n            } catch (error) {\n              if (error.message.includes('Cannot pass deleted object')) {\n                setIsActive(false);\n                console.error('MediaPipe instance was deleted, stopping processing');\n              } else {\n                console.error('Error in camera frame processing:', error);\n              }\n            }\n          },\n          width: 640,\n          height: 480\n        });\n\n        // Store camera instance in ref\n        cameraRef.current = camera;\n        await camera.start();\n        setIsLoading(false);\n      }\n    } catch (err) {\n      console.error('Error initializing pose detection:', err);\n      setError('Failed to initialize pose detection. Please try refreshing the page.');\n      setIsLoading(false);\n    }\n  }, [isActive, onResults]);\n  useEffect(() => {\n    // Initialize pose detection\n    initializePose();\n\n    // Cleanup function\n    return () => {\n      setIsActive(false);\n\n      // Clean up camera\n      if (cameraRef.current) {\n        try {\n          cameraRef.current.stop();\n        } catch (e) {\n          console.error('Error stopping camera:', e);\n        }\n        cameraRef.current = null;\n      }\n\n      // Clean up pose\n      if (poseRef.current) {\n        try {\n          poseRef.current.close();\n        } catch (e) {\n          console.error('Error closing pose:', e);\n        }\n        poseRef.current = null;\n      }\n    };\n  }, [initializePose]);\n\n  // Add reset functionality\n  const handleReset = useCallback(() => {\n    setIsActive(false);\n\n    // Clean up existing instances\n    if (cameraRef.current) {\n      cameraRef.current.stop();\n      cameraRef.current = null;\n    }\n    if (poseRef.current) {\n      poseRef.current.close();\n      poseRef.current = null;\n    }\n\n    // Reset states\n    setError(null);\n    setIsLoading(true);\n    setPoseAccuracy(0);\n    setSegmentAccuracies({});\n\n    // Reinitialize after a short delay\n    setTimeout(() => {\n      setIsActive(true);\n      initializePose();\n    }, 100);\n  }, [initializePose]);\n\n  // Modify error boundary\n  useEffect(() => {\n    const handleError = event => {\n      if (event.error && event.error.message && event.error.message.includes('Cannot pass deleted object')) {\n        console.error('MediaPipe error detected, resetting component...');\n        handleReset();\n      }\n    };\n    window.addEventListener('error', handleError);\n    return () => window.removeEventListener('error', handleError);\n  }, [handleReset]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"pose-tracker\",\n    children: [isLoading && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"loading\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Loading pose detector... Please wait a moment.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 423,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        style: {\n          fontSize: '0.9em',\n          color: '#666'\n        },\n        children: \"This may take a few seconds to initialize.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 424,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 422,\n      columnNumber: 17\n    }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"error\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: error\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 431,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleReset,\n        style: {\n          marginTop: '10px',\n          padding: '8px 16px',\n          backgroundColor: '#4CAF50',\n          color: 'white',\n          border: 'none',\n          borderRadius: '4px',\n          cursor: 'pointer'\n        },\n        children: \"Retry\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 432,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 430,\n      columnNumber: 17\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"camera-container\",\n      children: [/*#__PURE__*/_jsxDEV(Webcam, {\n        ref: webcamRef,\n        className: \"webcam\",\n        mirrored: true,\n        videoConstraints: videoConstraints\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 449,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        className: \"pose-canvas\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 455,\n        columnNumber: 17\n      }, this), selectedPose && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"accuracy-display\",\n        style: {\n          position: 'absolute',\n          top: '20px',\n          left: '20px',\n          background: 'rgba(0, 0, 0, 0.7)',\n          color: 'white',\n          padding: '15px',\n          borderRadius: '5px',\n          fontSize: '1.1em'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            marginBottom: '10px',\n            fontWeight: 'bold'\n          },\n          children: [\"Overall Accuracy: \", poseAccuracy, \"%\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 467,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontSize: '0.9em'\n          },\n          children: Object.entries(segmentAccuracies).map(([segment, data]) => /*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              marginBottom: '5px'\n            },\n            children: [segment.charAt(0).toUpperCase() + segment.slice(1), \": \", Math.round(data.accuracy), \"%\"]\n          }, segment, true, {\n            fileName: _jsxFileName,\n            lineNumber: 472,\n            columnNumber: 33\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 470,\n          columnNumber: 25\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 457,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 448,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 420,\n    columnNumber: 9\n  }, this);\n};\n_s(PoseTracker, \"3lZmJIN3uUmtTo1CVVFDZh1cujU=\");\n_c = PoseTracker;\nexport default PoseTracker;\nvar _c;\n$RefreshReg$(_c, \"PoseTracker\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","Webcam","Camera","Pose","jsxDEV","_jsxDEV","PoseTracker","selectedPose","_s","webcamRef","canvasRef","poseRef","cameraRef","isLoading","setIsLoading","error","setError","poseAccuracy","setPoseAccuracy","segmentAccuracies","setSegmentAccuracies","isActive","setIsActive","videoConstraints","width","height","facingMode","calculatePoseAccuracy","userLandmarks","targetPose","console","log","total","segments","calculateBodyScale","landmarks","scalePoints","points","type","point1","point2","visibility","distance","Math","sqrt","pow","x","y","userScale","targetScale","scaleRatio","bodySegments","head","upperBody","torso","lowerBody","segmentName","Object","entries","segmentTotal","segmentPoints","visiblePoints","totalVisibilityScore","forEach","index","userLandmark","targetLandmark","scaledUserX","scaledUserY","tolerance","pointAccuracy","max","weightedAccuracy","min","visibilityThreshold","averageVisibility","length","visibilityPercentage","segmentAccuracy","accuracy","totalAccuracy","totalWeight","data","weight","result","round","onResults","results","current","poseLandmarks","canvasElement","canvasCtx","getContext","videoWidth","video","videoHeight","accuracyData","clearRect","save","scale","translate","lineWidth","drawConnection","start","end","color","startPoint","endPoint","beginPath","moveTo","lineTo","strokeStyle","stroke","upperBodyColor","headColor","torsoColor","lowerBodyColor","landmark","arc","PI","fillStyle","fill","restore","initializePose","close","stop","pose","locateFile","file","setOptions","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","minDetectionConfidence","minTrackingConfidence","camera","onFrame","send","image","message","includes","err","e","handleReset","setTimeout","handleError","event","window","addEventListener","removeEventListener","className","children","fileName","_jsxFileName","lineNumber","columnNumber","style","fontSize","onClick","marginTop","padding","backgroundColor","border","borderRadius","cursor","ref","mirrored","position","top","left","background","marginBottom","fontWeight","map","segment","charAt","toUpperCase","slice","_c","$RefreshReg$"],"sources":["C:/Users/Quant/Documents/Programming/Projects/Hackathon/MakeUofT/frontend/src/components/PoseTracker.js"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\r\nimport Webcam from 'react-webcam';\r\nimport { Camera } from '@mediapipe/camera_utils';\r\nimport { Pose } from '@mediapipe/pose';\r\nimport './PoseTracker.css';\r\n\r\nconst PoseTracker = ({ selectedPose }) => {\r\n    const webcamRef = useRef(null);\r\n    const canvasRef = useRef(null);\r\n    const poseRef = useRef(null);\r\n    const cameraRef = useRef(null);\r\n    const [isLoading, setIsLoading] = useState(true);\r\n    const [error, setError] = useState(null);\r\n    const [poseAccuracy, setPoseAccuracy] = useState(0);\r\n    const [segmentAccuracies, setSegmentAccuracies] = useState({});\r\n    const [isActive, setIsActive] = useState(true);\r\n\r\n    const videoConstraints = {\r\n        width: 640,\r\n        height: 480,\r\n        facingMode: 'user',\r\n    };\r\n\r\n    const calculatePoseAccuracy = (userLandmarks, targetPose) => {\r\n        if (!targetPose || !userLandmarks) {\r\n            console.log('Missing data:', { targetPose: !!targetPose, userLandmarks: !!userLandmarks });\r\n            return { total: 0, segments: {} };\r\n        }\r\n\r\n        // Calculate scale factors based on body size in frame\r\n        const calculateBodyScale = (landmarks) => {\r\n            // Try different reference points for scaling based on what's visible\r\n            const scalePoints = [\r\n                // Shoulders width\r\n                { points: [11, 12], type: 'width' },\r\n                // Face width\r\n                { points: [7, 8], type: 'width' },\r\n                // Upper body height (neck to hips)\r\n                { points: [0, 23], type: 'height' },\r\n                // Arm length\r\n                { points: [11, 15], type: 'height' }\r\n            ];\r\n\r\n            for (const { points, type } of scalePoints) {\r\n                const point1 = landmarks[points[0]];\r\n                const point2 = landmarks[points[1]];\r\n\r\n                if (point1 && point2 && point1.visibility > 0.5 && point2.visibility > 0.5) {\r\n                    const distance = Math.sqrt(\r\n                        Math.pow(point1.x - point2.x, 2) +\r\n                        Math.pow(point1.y - point2.y, 2)\r\n                    );\r\n\r\n                    return {\r\n                        [type]: distance,\r\n                        width: type === 'width' ? distance : null,\r\n                        height: type === 'height' ? distance : null\r\n                    };\r\n                }\r\n            }\r\n\r\n            // If no reference points are found, return a default scale\r\n            return { width: 1, height: 1 };\r\n        };\r\n\r\n        const userScale = calculateBodyScale(userLandmarks);\r\n        const targetScale = calculateBodyScale(targetPose.landmarks);\r\n\r\n        // Calculate scale ratio between user and target pose\r\n        const scaleRatio = {\r\n            height: (targetScale.height && userScale.height) ? targetScale.height / userScale.height : 1,\r\n            width: (targetScale.width && userScale.width) ? targetScale.width / userScale.width : 1\r\n        };\r\n\r\n        // Define body segments with their corresponding landmark indices\r\n        const bodySegments = {\r\n            head: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\r\n            upperBody: [11, 12, 13, 14, 15, 16], // shoulders, elbows, wrists\r\n            torso: [11, 12, 23, 24], // shoulders to hips\r\n            lowerBody: [23, 24, 25, 26, 27, 28] // hips to ankles\r\n        };\r\n\r\n        let segmentAccuracies = {};\r\n\r\n        // Calculate accuracy for each body segment\r\n        for (const [segmentName, points] of Object.entries(bodySegments)) {\r\n            let segmentTotal = 0;\r\n            let segmentPoints = 0;\r\n            let visiblePoints = 0;\r\n            let totalVisibilityScore = 0;\r\n\r\n            points.forEach(index => {\r\n                const userLandmark = userLandmarks[index];\r\n                const targetLandmark = targetPose.landmarks[index];\r\n\r\n                if (!userLandmark || !targetLandmark) {\r\n                    return;\r\n                }\r\n\r\n                // Add to visibility score even if below threshold\r\n                totalVisibilityScore += userLandmark.visibility;\r\n\r\n                // More lenient visibility threshold\r\n                if (userLandmark.visibility > 0.05 && targetLandmark.visibility > 0.05) {\r\n                    visiblePoints++;\r\n\r\n                    // Scale the user's coordinates based on the calculated ratio\r\n                    const scaledUserX = userLandmark.x * scaleRatio.width;\r\n                    const scaledUserY = userLandmark.y * scaleRatio.height;\r\n\r\n                    // Calculate Euclidean distance using scaled coordinates\r\n                    const distance = Math.sqrt(\r\n                        Math.pow(scaledUserX - targetLandmark.x, 2) +\r\n                        Math.pow(scaledUserY - targetLandmark.y, 2)\r\n                    );\r\n\r\n                    // Adjust tolerance based on the segment and visibility\r\n                    let tolerance = 0.2; // Increased base tolerance\r\n                    if (segmentName === 'head') {\r\n                        tolerance = 0.15;\r\n                    } else if (segmentName === 'lowerBody') {\r\n                        tolerance = 0.25;\r\n                    }\r\n\r\n                    // Make tolerance more forgiving for partially visible points\r\n                    tolerance = tolerance * (1 + (1 - userLandmark.visibility) * 0.5);\r\n\r\n                    // Convert distance to accuracy (closer = higher accuracy)\r\n                    const pointAccuracy = Math.max(0, 1 - (distance / tolerance));\r\n\r\n                    // Weight the accuracy by visibility\r\n                    const weightedAccuracy = pointAccuracy * Math.min(userLandmark.visibility, targetLandmark.visibility);\r\n                    segmentTotal += weightedAccuracy;\r\n                    segmentPoints++;\r\n                }\r\n            });\r\n\r\n            // More lenient visibility threshold for segments\r\n            const visibilityThreshold = 0.05; // Lowered threshold significantly\r\n            const averageVisibility = totalVisibilityScore / points.length;\r\n            const visibilityPercentage = visiblePoints / points.length;\r\n\r\n            // Include segment if it has any visible points\r\n            if (visibilityPercentage > visibilityThreshold && segmentPoints > 0) {\r\n                const segmentAccuracy = (segmentTotal / segmentPoints) * 100;\r\n                segmentAccuracies[segmentName] = {\r\n                    accuracy: segmentAccuracy * Math.min(1, averageVisibility * 2),\r\n                    visibility: visibilityPercentage\r\n                };\r\n            }\r\n        }\r\n\r\n        // Calculate weighted average of visible segment accuracies\r\n        let totalAccuracy = 0;\r\n        let totalWeight = 0;\r\n\r\n        for (const [, data] of Object.entries(segmentAccuracies)) {\r\n            const weight = data.visibility;\r\n            totalAccuracy += data.accuracy * weight;\r\n            totalWeight += weight;\r\n        }\r\n\r\n        const result = {\r\n            total: Math.round(totalWeight > 0 ? totalAccuracy / totalWeight : 0),\r\n            segments: segmentAccuracies\r\n        };\r\n\r\n        return result;\r\n    };\r\n\r\n    const onResults = useCallback((results) => {\r\n        if (!canvasRef.current || !results.poseLandmarks) return;\r\n\r\n        const canvasElement = canvasRef.current;\r\n        const canvasCtx = canvasElement.getContext('2d');\r\n        const videoWidth = webcamRef.current.video.videoWidth;\r\n        const videoHeight = webcamRef.current.video.videoHeight;\r\n\r\n        // Set canvas dimensions to match video\r\n        canvasElement.width = videoWidth;\r\n        canvasElement.height = videoHeight;\r\n\r\n        // Calculate pose accuracy if we have a selected pose\r\n        if (selectedPose) {\r\n            console.log('Processing frame with selected pose:', selectedPose);\r\n            const accuracyData = calculatePoseAccuracy(results.poseLandmarks, selectedPose);\r\n            setPoseAccuracy(accuracyData.total);\r\n            setSegmentAccuracies(accuracyData.segments);\r\n        } else {\r\n            console.log('No pose selected');\r\n        }\r\n\r\n        // Clear canvas\r\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\r\n\r\n        // Draw pose landmarks\r\n        if (results.poseLandmarks) {\r\n            // Draw the pose landmarks\r\n            canvasCtx.save();\r\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\r\n\r\n            // Mirror the canvas context\r\n            canvasCtx.scale(-1, 1);\r\n            canvasCtx.translate(-videoWidth, 0);\r\n\r\n            // Draw connectors\r\n            canvasCtx.lineWidth = 3;\r\n\r\n            // Draw pose connections\r\n            function drawConnection(landmarks, start, end, color) {\r\n                const startPoint = landmarks[start];\r\n                const endPoint = landmarks[end];\r\n\r\n                if (startPoint.visibility > 0.5 && endPoint.visibility > 0.5) {\r\n                    canvasCtx.beginPath();\r\n                    canvasCtx.moveTo(startPoint.x * videoWidth, startPoint.y * videoHeight);\r\n                    canvasCtx.lineTo(endPoint.x * videoWidth, endPoint.y * videoHeight);\r\n                    canvasCtx.strokeStyle = color;\r\n                    canvasCtx.stroke();\r\n                }\r\n            }\r\n\r\n            const landmarks = results.poseLandmarks;\r\n\r\n            // Draw body parts with different colors\r\n            // Upper body (green)\r\n            const upperBodyColor = '#00FF00';\r\n            drawConnection(landmarks, 11, 12, upperBodyColor); // shoulders\r\n            drawConnection(landmarks, 11, 13, upperBodyColor); // left upper arm\r\n            drawConnection(landmarks, 13, 15, upperBodyColor); // left lower arm\r\n            drawConnection(landmarks, 12, 14, upperBodyColor); // right upper arm\r\n            drawConnection(landmarks, 14, 16, upperBodyColor); // right lower arm\r\n\r\n            // Head (red)\r\n            const headColor = '#FF0000';\r\n            drawConnection(landmarks, 0, 1, headColor);\r\n            drawConnection(landmarks, 1, 2, headColor);\r\n            drawConnection(landmarks, 2, 3, headColor);\r\n            drawConnection(landmarks, 3, 7, headColor);\r\n            drawConnection(landmarks, 0, 4, headColor);\r\n            drawConnection(landmarks, 4, 5, headColor);\r\n            drawConnection(landmarks, 5, 6, headColor);\r\n            drawConnection(landmarks, 6, 8, headColor);\r\n\r\n            // Torso (blue)\r\n            const torsoColor = '#0000FF';\r\n            drawConnection(landmarks, 11, 23, torsoColor); // left shoulder to hip\r\n            drawConnection(landmarks, 12, 24, torsoColor); // right shoulder to hip\r\n            drawConnection(landmarks, 23, 24, torsoColor); // hips\r\n\r\n            // Lower body (yellow)\r\n            const lowerBodyColor = '#FFFF00';\r\n            drawConnection(landmarks, 23, 25, lowerBodyColor); // left hip to knee\r\n            drawConnection(landmarks, 25, 27, lowerBodyColor); // left knee to ankle\r\n            drawConnection(landmarks, 24, 26, lowerBodyColor); // right hip to knee\r\n            drawConnection(landmarks, 26, 28, lowerBodyColor); // right knee to ankle\r\n\r\n            // Draw landmarks\r\n            landmarks.forEach((landmark, index) => {\r\n                if (landmark.visibility > 0.5) {\r\n                    canvasCtx.beginPath();\r\n                    canvasCtx.arc(\r\n                        landmark.x * videoWidth,\r\n                        landmark.y * videoHeight,\r\n                        5,\r\n                        0,\r\n                        2 * Math.PI\r\n                    );\r\n                    canvasCtx.fillStyle = '#FFFFFF';\r\n                    canvasCtx.fill();\r\n                    canvasCtx.strokeStyle = '#000000';\r\n                    canvasCtx.stroke();\r\n                }\r\n            });\r\n\r\n            canvasCtx.restore();\r\n        }\r\n    }, [selectedPose]);\r\n\r\n    // Move initializePose outside useEffect so it can be used by handleReset\r\n    const initializePose = useCallback(async () => {\r\n        try {\r\n            // Clean up any existing instances\r\n            if (poseRef.current) {\r\n                poseRef.current.close();\r\n            }\r\n            if (cameraRef.current) {\r\n                cameraRef.current.stop();\r\n            }\r\n\r\n            // Create new pose instance\r\n            const pose = new Pose({\r\n                locateFile: (file) => {\r\n                    return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\r\n                }\r\n            });\r\n\r\n            // Store pose instance in ref\r\n            poseRef.current = pose;\r\n\r\n            // Configure pose options\r\n            await pose.setOptions({\r\n                modelComplexity: 1,\r\n                smoothLandmarks: true,\r\n                enableSegmentation: false,\r\n                smoothSegmentation: false,\r\n                minDetectionConfidence: 0.5,\r\n                minTrackingConfidence: 0.5\r\n            });\r\n\r\n            // Set up pose callback\r\n            pose.onResults(onResults);\r\n\r\n            // Initialize camera only if component is still mounted\r\n            if (webcamRef.current && webcamRef.current.video) {\r\n                const camera = new Camera(webcamRef.current.video, {\r\n                    onFrame: async () => {\r\n                        if (!isActive) return;\r\n                        try {\r\n                            if (poseRef.current && webcamRef.current && webcamRef.current.video) {\r\n                                await poseRef.current.send({ image: webcamRef.current.video });\r\n                            }\r\n                        } catch (error) {\r\n                            if (error.message.includes('Cannot pass deleted object')) {\r\n                                setIsActive(false);\r\n                                console.error('MediaPipe instance was deleted, stopping processing');\r\n                            } else {\r\n                                console.error('Error in camera frame processing:', error);\r\n                            }\r\n                        }\r\n                    },\r\n                    width: 640,\r\n                    height: 480\r\n                });\r\n\r\n                // Store camera instance in ref\r\n                cameraRef.current = camera;\r\n\r\n                await camera.start();\r\n                setIsLoading(false);\r\n            }\r\n        } catch (err) {\r\n            console.error('Error initializing pose detection:', err);\r\n            setError('Failed to initialize pose detection. Please try refreshing the page.');\r\n            setIsLoading(false);\r\n        }\r\n    }, [isActive, onResults]);\r\n\r\n    useEffect(() => {\r\n        // Initialize pose detection\r\n        initializePose();\r\n\r\n        // Cleanup function\r\n        return () => {\r\n            setIsActive(false);\r\n\r\n            // Clean up camera\r\n            if (cameraRef.current) {\r\n                try {\r\n                    cameraRef.current.stop();\r\n                } catch (e) {\r\n                    console.error('Error stopping camera:', e);\r\n                }\r\n                cameraRef.current = null;\r\n            }\r\n\r\n            // Clean up pose\r\n            if (poseRef.current) {\r\n                try {\r\n                    poseRef.current.close();\r\n                } catch (e) {\r\n                    console.error('Error closing pose:', e);\r\n                }\r\n                poseRef.current = null;\r\n            }\r\n        };\r\n    }, [initializePose]);\r\n\r\n    // Add reset functionality\r\n    const handleReset = useCallback(() => {\r\n        setIsActive(false);\r\n\r\n        // Clean up existing instances\r\n        if (cameraRef.current) {\r\n            cameraRef.current.stop();\r\n            cameraRef.current = null;\r\n        }\r\n        if (poseRef.current) {\r\n            poseRef.current.close();\r\n            poseRef.current = null;\r\n        }\r\n\r\n        // Reset states\r\n        setError(null);\r\n        setIsLoading(true);\r\n        setPoseAccuracy(0);\r\n        setSegmentAccuracies({});\r\n\r\n        // Reinitialize after a short delay\r\n        setTimeout(() => {\r\n            setIsActive(true);\r\n            initializePose();\r\n        }, 100);\r\n    }, [initializePose]);\r\n\r\n    // Modify error boundary\r\n    useEffect(() => {\r\n        const handleError = (event) => {\r\n            if (event.error && event.error.message && event.error.message.includes('Cannot pass deleted object')) {\r\n                console.error('MediaPipe error detected, resetting component...');\r\n                handleReset();\r\n            }\r\n        };\r\n\r\n        window.addEventListener('error', handleError);\r\n        return () => window.removeEventListener('error', handleError);\r\n    }, [handleReset]);\r\n\r\n    return (\r\n        <div className=\"pose-tracker\">\r\n            {isLoading && (\r\n                <div className=\"loading\">\r\n                    <p>Loading pose detector... Please wait a moment.</p>\r\n                    <p style={{ fontSize: '0.9em', color: '#666' }}>\r\n                        This may take a few seconds to initialize.\r\n                    </p>\r\n                </div>\r\n            )}\r\n            {error && (\r\n                <div className=\"error\">\r\n                    <p>{error}</p>\r\n                    <button\r\n                        onClick={handleReset}\r\n                        style={{\r\n                            marginTop: '10px',\r\n                            padding: '8px 16px',\r\n                            backgroundColor: '#4CAF50',\r\n                            color: 'white',\r\n                            border: 'none',\r\n                            borderRadius: '4px',\r\n                            cursor: 'pointer',\r\n                        }}\r\n                    >\r\n                        Retry\r\n                    </button>\r\n                </div>\r\n            )}\r\n            <div className=\"camera-container\">\r\n                <Webcam\r\n                    ref={webcamRef}\r\n                    className=\"webcam\"\r\n                    mirrored={true}\r\n                    videoConstraints={videoConstraints}\r\n                />\r\n                <canvas ref={canvasRef} className=\"pose-canvas\" />\r\n                {selectedPose && (\r\n                    <div className=\"accuracy-display\" style={{\r\n                        position: 'absolute',\r\n                        top: '20px',\r\n                        left: '20px',\r\n                        background: 'rgba(0, 0, 0, 0.7)',\r\n                        color: 'white',\r\n                        padding: '15px',\r\n                        borderRadius: '5px',\r\n                        fontSize: '1.1em'\r\n                    }}>\r\n                        <div style={{ marginBottom: '10px', fontWeight: 'bold' }}>\r\n                            Overall Accuracy: {poseAccuracy}%\r\n                        </div>\r\n                        <div style={{ fontSize: '0.9em' }}>\r\n                            {Object.entries(segmentAccuracies).map(([segment, data]) => (\r\n                                <div key={segment} style={{ marginBottom: '5px' }}>\r\n                                    {segment.charAt(0).toUpperCase() + segment.slice(1)}: {Math.round(data.accuracy)}%\r\n                                </div>\r\n                            ))}\r\n                        </div>\r\n                    </div>\r\n                )}\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default PoseTracker;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}