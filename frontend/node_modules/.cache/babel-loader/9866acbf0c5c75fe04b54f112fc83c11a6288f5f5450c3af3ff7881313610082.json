{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Quant\\\\Documents\\\\Programming\\\\Projects\\\\Hackathon\\\\MakeUofT\\\\frontend\\\\src\\\\components\\\\PoseTracker.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport Webcam from 'react-webcam';\nimport { Camera } from '@mediapipe/camera_utils';\nimport { Pose } from '@mediapipe/pose';\nimport './PoseTracker.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst PoseTracker = ({\n  userPreferences\n}) => {\n  _s();\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n  const poseRef = useRef(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [poseAccuracy, setPoseAccuracy] = useState(0);\n  const [segmentAccuracies, setSegmentAccuracies] = useState({});\n  const [poseFeedback, setPoseFeedback] = useState('');\n  const [wsConnection, setWsConnection] = useState(null);\n  const [selectedPose, setSelectedPose] = useState(null);\n  const [debugInfo, setDebugInfo] = useState({});\n  const videoConstraints = {\n    width: 640,\n    height: 480,\n    facingMode: 'user'\n  };\n  const calculatePoseAccuracy = (userLandmarks, targetPose) => {\n    if (!targetPose || !userLandmarks) {\n      console.log('Missing data:', {\n        hasTargetPose: !!targetPose,\n        hasUserLandmarks: !!userLandmarks\n      });\n      return {\n        total: 0,\n        segments: {}\n      };\n    }\n\n    // Add debug logging\n    console.log('Calculating accuracy with:', {\n      userLandmarksCount: userLandmarks.length,\n      targetPoseLandmarksCount: targetPose.landmarks.length\n    });\n\n    // Define body segments with their corresponding landmark indices\n    const bodySegments = {\n      head: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      upperBody: [11, 12, 13, 14, 15, 16],\n      torso: [11, 12, 23, 24],\n      lowerBody: [23, 24, 25, 26, 27, 28]\n    };\n\n    // Define key points that must be visible for each segment\n    const requiredPoints = {\n      head: [0],\n      // Only require nose\n      upperBody: [11, 12],\n      // Shoulders\n      torso: [11, 24],\n      // One shoulder and opposite hip\n      lowerBody: [24, 26] // One hip and opposite knee\n    };\n\n    // Helper function to normalize pose relative to height\n    const normalizePose = landmarks => {\n      // Find the topmost and bottommost visible points\n      let minY = Number.MAX_VALUE;\n      let maxY = Number.MIN_VALUE;\n      let minX = Number.MAX_VALUE;\n      let maxX = Number.MIN_VALUE;\n      landmarks.forEach(landmark => {\n        if (landmark.visibility > 0.3) {\n          minY = Math.min(minY, landmark.y);\n          maxY = Math.max(maxY, landmark.y);\n          minX = Math.min(minX, landmark.x);\n          maxX = Math.max(maxX, landmark.x);\n        }\n      });\n      const height = maxY - minY;\n      const width = maxX - minX;\n      const centerX = (minX + maxX) / 2;\n      const centerY = (minY + maxY) / 2;\n      if (height === 0 || width === 0) return landmarks;\n      return landmarks.map(landmark => ({\n        x: (landmark.x - centerX) / width,\n        y: (landmark.y - centerY) / height,\n        visibility: landmark.visibility\n      }));\n    };\n\n    // Normalize both poses\n    const normalizedUser = normalizePose(userLandmarks);\n    const normalizedTarget = normalizePose(targetPose.landmarks);\n    let segmentAccuracies = {};\n    let visibleSegments = 0;\n\n    // Calculate accuracy for each body segment\n    for (const [segment, points] of Object.entries(bodySegments)) {\n      // Check if required points are visible\n      const requiredVisible = requiredPoints[segment].every(index => {\n        const userPoint = normalizedUser[index];\n        const targetPoint = normalizedTarget[index];\n        return userPoint.visibility > 0.3 && targetPoint.visibility > 0.3;\n      });\n      if (!requiredVisible) continue;\n      let segmentTotal = 0;\n      let segmentPoints = 0;\n\n      // Calculate accuracies for points\n      points.forEach(index => {\n        const userLandmark = normalizedUser[index];\n        const targetLandmark = normalizedTarget[index];\n\n        // Lower visibility threshold for legs\n        const visibilityThreshold = segment === 'lowerBody' ? 0.3 : 0.4;\n        if (userLandmark.visibility > visibilityThreshold && targetLandmark.visibility > visibilityThreshold) {\n          // Calculate position difference\n          const distance = Math.sqrt(Math.pow(userLandmark.x - targetLandmark.x, 2) + Math.pow(userLandmark.y - targetLandmark.y, 2));\n\n          // Calculate relative angle to center\n          const userAngle = Math.atan2(userLandmark.y, userLandmark.x);\n          const targetAngle = Math.atan2(targetLandmark.y, targetLandmark.x);\n          const angleDiff = Math.abs(userAngle - targetAngle);\n\n          // Adjust weights based on segment\n          let angleWeight = 0.5;\n          let distanceWeight = 0.5;\n          if (segment === 'lowerBody') {\n            angleWeight = 0.7; // More emphasis on angle for legs\n            distanceWeight = 0.3;\n          }\n\n          // Calculate point accuracy\n          const angleAccuracy = Math.max(0, 1 - angleDiff / Math.PI);\n          const distanceAccuracy = Math.max(0, 1 - distance / 1.0); // Increased tolerance\n          const pointAccuracy = angleAccuracy * angleWeight + distanceAccuracy * distanceWeight;\n\n          // Use visibility for accuracy weight but count point as fully visible\n          const visibilityWeight = Math.min(userLandmark.visibility, targetLandmark.visibility);\n          segmentTotal += pointAccuracy * visibilityWeight;\n          segmentPoints += 1; // Count as one visible point instead of using visibility value\n        }\n      });\n\n      // Calculate segment accuracy if we have points\n      if (segmentPoints > 0) {\n        const rawAccuracy = segmentTotal / segmentPoints * 100;\n\n        // Calculate visibility as a weighted average based on point importance\n        const visibilityWeight = points.reduce((sum, index) => {\n          const landmark = normalizedUser[index];\n          // Use a more lenient visibility threshold and smooth the transition\n          return sum + (landmark.visibility > 0.2 ? Math.min(1, landmark.visibility * 1.5) : 0);\n        }, 0);\n        const visibilityPercentage = visibilityWeight / points.length;\n        segmentAccuracies[segment] = {\n          accuracy: Math.min(100, Math.max(0, rawAccuracy)),\n          visibility: visibilityPercentage\n        };\n        visibleSegments++;\n      }\n    }\n\n    // Calculate overall accuracy with adjusted weights\n    if (visibleSegments === 0) return {\n      total: 0,\n      segments: {}\n    };\n    let totalAccuracy = 0;\n    let totalWeight = 0;\n    const segmentWeights = {\n      head: 0.8,\n      upperBody: 1.0,\n      torso: 1.0,\n      lowerBody: 1.2\n    };\n    for (const [segment, data] of Object.entries(segmentAccuracies)) {\n      const weight = segmentWeights[segment] * Math.pow(data.visibility, 0.5); // Sqrt to reduce penalty of low visibility\n      totalAccuracy += data.accuracy * weight;\n      totalWeight += weight;\n    }\n\n    // Add more detailed debug info\n    setDebugInfo({\n      visibleSegments,\n      segmentAccuracies,\n      userLandmarksPresent: userLandmarks.length,\n      targetLandmarksPresent: targetPose.landmarks.length\n    });\n    return {\n      total: Math.round(totalWeight > 0 ? totalAccuracy / totalWeight : 0),\n      segments: segmentAccuracies\n    };\n  };\n  const onResults = useCallback(results => {\n    var _selectedPose$landmar;\n    if (!canvasRef.current || !results.poseLandmarks) {\n      console.log('Missing canvas or landmarks');\n      return;\n    }\n\n    // Log the incoming data\n    console.log('Received pose landmarks:', {\n      landmarksCount: results.poseLandmarks.length,\n      hasSelectedPose: !!selectedPose,\n      selectedPoseLandmarks: selectedPose === null || selectedPose === void 0 ? void 0 : (_selectedPose$landmar = selectedPose.landmarks) === null || _selectedPose$landmar === void 0 ? void 0 : _selectedPose$landmar.length\n    });\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext('2d');\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight;\n\n    // Set canvas dimensions to match video\n    canvasElement.width = videoWidth;\n    canvasElement.height = videoHeight;\n\n    // Calculate pose accuracy if we have a selected pose\n    if (selectedPose && selectedPose.landmarks) {\n      const accuracyData = calculatePoseAccuracy(results.poseLandmarks, selectedPose);\n      setPoseAccuracy(accuracyData.total);\n      setSegmentAccuracies(accuracyData.segments);\n    }\n\n    // Clear canvas\n    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n    // Draw pose landmarks\n    if (results.poseLandmarks) {\n      // Save the current context state\n      canvasCtx.save();\n\n      // Clear the canvas\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n      // Mirror the context\n      canvasCtx.scale(-1, 1);\n      canvasCtx.translate(-videoWidth, 0);\n\n      // Draw pose connections with adjusted line width based on video dimensions\n      function drawConnection(landmarks, start, end, color) {\n        const startPoint = landmarks[start];\n        const endPoint = landmarks[end];\n        if (startPoint.visibility > 0.5 && endPoint.visibility > 0.5) {\n          canvasCtx.beginPath();\n          canvasCtx.moveTo(startPoint.x * videoWidth, startPoint.y * videoHeight);\n          canvasCtx.lineTo(endPoint.x * videoWidth, endPoint.y * videoHeight);\n          canvasCtx.strokeStyle = color;\n          // Adjust line width based on video dimensions\n          canvasCtx.lineWidth = Math.max(3, videoWidth / 200);\n          canvasCtx.stroke();\n        }\n      }\n      const landmarks = results.poseLandmarks;\n\n      // Draw body parts with different colors\n      // Upper body (green)\n      const upperBodyColor = '#00FF00';\n      drawConnection(landmarks, 12, 11, upperBodyColor); // shoulders\n      drawConnection(landmarks, 12, 14, upperBodyColor); // right upper arm\n      drawConnection(landmarks, 14, 16, upperBodyColor); // right lower arm\n      drawConnection(landmarks, 11, 13, upperBodyColor); // left upper arm\n      drawConnection(landmarks, 13, 15, upperBodyColor); // left lower arm\n\n      // Head (red)\n      const headColor = '#FF0000';\n      drawConnection(landmarks, 0, 4, headColor);\n      drawConnection(landmarks, 4, 5, headColor);\n      drawConnection(landmarks, 5, 6, headColor);\n      drawConnection(landmarks, 6, 8, headColor);\n      drawConnection(landmarks, 0, 1, headColor);\n      drawConnection(landmarks, 1, 2, headColor);\n      drawConnection(landmarks, 2, 3, headColor);\n      drawConnection(landmarks, 3, 7, headColor);\n\n      // Torso (blue)\n      const torsoColor = '#0000FF';\n      drawConnection(landmarks, 12, 24, torsoColor); // right shoulder to hip\n      drawConnection(landmarks, 11, 23, torsoColor); // left shoulder to hip\n      drawConnection(landmarks, 24, 23, torsoColor); // hips\n\n      // Lower body (yellow)\n      const lowerBodyColor = '#FFFF00';\n      drawConnection(landmarks, 24, 26, lowerBodyColor); // right hip to knee\n      drawConnection(landmarks, 26, 28, lowerBodyColor); // right knee to ankle\n      drawConnection(landmarks, 23, 25, lowerBodyColor); // left hip to knee\n      drawConnection(landmarks, 25, 27, lowerBodyColor); // left knee to ankle\n\n      // Draw landmarks with size relative to video dimensions\n      landmarks.forEach(landmark => {\n        if (landmark.visibility > 0.5) {\n          canvasCtx.beginPath();\n          const pointSize = Math.max(5, videoWidth / 100);\n          canvasCtx.arc(landmark.x * videoWidth, landmark.y * videoHeight, pointSize, 0, 2 * Math.PI);\n          canvasCtx.fillStyle = '#FFFFFF';\n          canvasCtx.fill();\n          canvasCtx.strokeStyle = '#000000';\n          canvasCtx.lineWidth = Math.max(2, videoWidth / 400);\n          canvasCtx.stroke();\n        }\n      });\n\n      // Restore the context state\n      canvasCtx.restore();\n    }\n  }, [selectedPose]);\n  useEffect(() => {\n    let pose = null;\n    let camera = null;\n    const initializePose = async () => {\n      try {\n        // Create pose detector with updated initialization\n        pose = new Pose({\n          locateFile: file => {\n            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${file}`;\n          }\n        });\n\n        // Configure pose detection - set selfieMode to false to prevent double mirroring\n        await pose.setOptions({\n          modelComplexity: 1,\n          smoothLandmarks: true,\n          minDetectionConfidence: 0.5,\n          minTrackingConfidence: 0.5,\n          selfieMode: false // Changed to false to prevent double mirroring\n        });\n\n        // Set up result handler\n        await pose.onResults(onResults);\n\n        // Initialize camera after pose is ready\n        if (webcamRef.current && webcamRef.current.video) {\n          camera = new Camera(webcamRef.current.video, {\n            onFrame: async () => {\n              try {\n                if (webcamRef.current && webcamRef.current.video) {\n                  await pose.send({\n                    image: webcamRef.current.video\n                  });\n                }\n              } catch (err) {\n                console.error('Error in camera frame processing:', err);\n              }\n            },\n            width: 640,\n            height: 480\n          });\n          await camera.start();\n          setIsLoading(false);\n        }\n      } catch (err) {\n        console.error('Error initializing pose detection:', err);\n        setError('Failed to initialize pose detection. Please try refreshing the page.');\n        setIsLoading(false);\n      }\n    };\n\n    // Initialize pose detection\n    initializePose();\n\n    // Cleanup function\n    return () => {\n      if (camera) {\n        camera.stop();\n      }\n      if (pose) {\n        pose.close();\n      }\n    };\n  }, [onResults]);\n  useEffect(() => {\n    // Initialize WebSocket connection\n    const ws = new WebSocket('ws://localhost:8000/ws/pose-feedback');\n    ws.onopen = () => {\n      console.log('Connected to feedback server');\n      setWsConnection(ws);\n    };\n    ws.onmessage = event => {\n      setPoseFeedback(event.data);\n    };\n    ws.onerror = error => {\n      console.error('WebSocket error:', error);\n    };\n    return () => {\n      if (ws) {\n        ws.close();\n      }\n    };\n  }, []);\n\n  // Send pose data to backend when accuracy updates\n  useEffect(() => {\n    if (wsConnection && selectedPose && Object.keys(segmentAccuracies).length > 0) {\n      const poseData = {\n        pose_name: selectedPose.name || 'unknown pose',\n        overall_accuracy: poseAccuracy,\n        segment_accuracies: segmentAccuracies\n      };\n      wsConnection.send(JSON.stringify(poseData));\n    }\n  }, [poseAccuracy, segmentAccuracies, selectedPose, wsConnection]);\n\n  // Load initial pose\n  useEffect(() => {\n    const loadPose = async () => {\n      try {\n        // For testing, we'll load a specific pose\n        const response = await fetch('/pose_results/tree-pose_pose.json');\n        if (!response.ok) {\n          throw new Error('Failed to load pose data');\n        }\n        const poseData = await response.json();\n        console.log('Loaded pose data:', poseData);\n        setSelectedPose(poseData);\n      } catch (err) {\n        console.error('Error loading pose data:', err);\n        setError('Failed to load pose data');\n      }\n    };\n    loadPose();\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"pose-tracker\",\n    children: [isLoading && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"loading\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Loading pose detector... Please wait a moment.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 453,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        style: {\n          fontSize: '0.9em',\n          color: '#666'\n        },\n        children: \"This may take a few seconds to initialize.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 454,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 452,\n      columnNumber: 17\n    }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"error\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: error\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 461,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => window.location.reload(),\n        className: \"retry-button\",\n        children: \"Retry\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 462,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 460,\n      columnNumber: 17\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"camera-container\",\n      children: [/*#__PURE__*/_jsxDEV(Webcam, {\n        ref: webcamRef,\n        className: \"webcam\",\n        mirrored: true,\n        videoConstraints: videoConstraints\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 471,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        className: \"pose-canvas\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 477,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"debug-info\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          children: [\"Selected Pose: \", selectedPose ? 'Loaded' : 'Not Loaded']\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 481,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [\"Landmarks: \", selectedPose !== null && selectedPose !== void 0 && selectedPose.landmarks ? selectedPose.landmarks.length : 'None']\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 482,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [\"Visible Segments: \", debugInfo.visibleSegments || 0]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 483,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [\"User Landmarks: \", debugInfo.userLandmarksPresent || 0]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 484,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 480,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"accuracy-display\",\n        style: {\n          position: 'absolute',\n          top: '10px',\n          right: '10px',\n          background: 'rgba(0,0,0,0.7)',\n          color: 'white',\n          padding: '15px',\n          borderRadius: '5px',\n          minWidth: '200px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"accuracy-overall\",\n          style: {\n            fontSize: '18px',\n            marginBottom: '10px'\n          },\n          children: [\"Overall Accuracy: \", poseAccuracy, \"%\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 498,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"accuracy-segments\",\n          children: Object.entries(segmentAccuracies).map(([segment, data]) => /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"accuracy-segment\",\n            style: {\n              marginBottom: '5px',\n              display: 'flex',\n              justifyContent: 'space-between'\n            },\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              children: [segment.charAt(0).toUpperCase() + segment.slice(1), \":\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 508,\n              columnNumber: 33\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              children: [Math.round(data.accuracy), \"% (\", Math.round(data.visibility * 100), \"% visible)\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 509,\n              columnNumber: 33\n            }, this)]\n          }, segment, true, {\n            fileName: _jsxFileName,\n            lineNumber: 503,\n            columnNumber: 29\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 501,\n          columnNumber: 21\n        }, this), Object.keys(segmentAccuracies).length === 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            color: '#ff9999',\n            marginTop: '10px'\n          },\n          children: \"No segments detected. Make sure your full body is visible in the camera.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 514,\n          columnNumber: 25\n        }, this), poseFeedback && /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"pose-feedback\",\n          style: {\n            marginTop: '15px',\n            borderTop: '1px solid rgba(255,255,255,0.3)',\n            paddingTop: '10px'\n          },\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"feedback-title\",\n            style: {\n              fontWeight: 'bold',\n              marginBottom: '5px'\n            },\n            children: \"Instructor Feedback:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 520,\n            columnNumber: 29\n          }, this), poseFeedback]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 519,\n          columnNumber: 25\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 488,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 470,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 450,\n    columnNumber: 9\n  }, this);\n};\n_s(PoseTracker, \"wQCHa+ckywU9QW3IDUG2381l23k=\");\n_c = PoseTracker;\nexport default PoseTracker;\nvar _c;\n$RefreshReg$(_c, \"PoseTracker\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","Webcam","Camera","Pose","jsxDEV","_jsxDEV","PoseTracker","userPreferences","_s","webcamRef","canvasRef","poseRef","isLoading","setIsLoading","error","setError","poseAccuracy","setPoseAccuracy","segmentAccuracies","setSegmentAccuracies","poseFeedback","setPoseFeedback","wsConnection","setWsConnection","selectedPose","setSelectedPose","debugInfo","setDebugInfo","videoConstraints","width","height","facingMode","calculatePoseAccuracy","userLandmarks","targetPose","console","log","hasTargetPose","hasUserLandmarks","total","segments","userLandmarksCount","length","targetPoseLandmarksCount","landmarks","bodySegments","head","upperBody","torso","lowerBody","requiredPoints","normalizePose","minY","Number","MAX_VALUE","maxY","MIN_VALUE","minX","maxX","forEach","landmark","visibility","Math","min","y","max","x","centerX","centerY","map","normalizedUser","normalizedTarget","visibleSegments","segment","points","Object","entries","requiredVisible","every","index","userPoint","targetPoint","segmentTotal","segmentPoints","userLandmark","targetLandmark","visibilityThreshold","distance","sqrt","pow","userAngle","atan2","targetAngle","angleDiff","abs","angleWeight","distanceWeight","angleAccuracy","PI","distanceAccuracy","pointAccuracy","visibilityWeight","rawAccuracy","reduce","sum","visibilityPercentage","accuracy","totalAccuracy","totalWeight","segmentWeights","data","weight","userLandmarksPresent","targetLandmarksPresent","round","onResults","results","_selectedPose$landmar","current","poseLandmarks","landmarksCount","hasSelectedPose","selectedPoseLandmarks","canvasElement","canvasCtx","getContext","videoWidth","video","videoHeight","accuracyData","clearRect","save","scale","translate","drawConnection","start","end","color","startPoint","endPoint","beginPath","moveTo","lineTo","strokeStyle","lineWidth","stroke","upperBodyColor","headColor","torsoColor","lowerBodyColor","pointSize","arc","fillStyle","fill","restore","pose","camera","initializePose","locateFile","file","setOptions","modelComplexity","smoothLandmarks","minDetectionConfidence","minTrackingConfidence","selfieMode","onFrame","send","image","err","stop","close","ws","WebSocket","onopen","onmessage","event","onerror","keys","poseData","pose_name","name","overall_accuracy","segment_accuracies","JSON","stringify","loadPose","response","fetch","ok","Error","json","className","children","fileName","_jsxFileName","lineNumber","columnNumber","style","fontSize","onClick","window","location","reload","ref","mirrored","position","top","right","background","padding","borderRadius","minWidth","marginBottom","display","justifyContent","charAt","toUpperCase","slice","marginTop","borderTop","paddingTop","fontWeight","_c","$RefreshReg$"],"sources":["C:/Users/Quant/Documents/Programming/Projects/Hackathon/MakeUofT/frontend/src/components/PoseTracker.js"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\nimport Webcam from 'react-webcam';\nimport { Camera } from '@mediapipe/camera_utils';\nimport { Pose } from '@mediapipe/pose';\nimport './PoseTracker.css';\n\nconst PoseTracker = ({ userPreferences }) => {\n    const webcamRef = useRef(null);\n    const canvasRef = useRef(null);\n    const poseRef = useRef(null);\n    const [isLoading, setIsLoading] = useState(true);\n    const [error, setError] = useState(null);\n    const [poseAccuracy, setPoseAccuracy] = useState(0);\n    const [segmentAccuracies, setSegmentAccuracies] = useState({});\n    const [poseFeedback, setPoseFeedback] = useState('');\n    const [wsConnection, setWsConnection] = useState(null);\n    const [selectedPose, setSelectedPose] = useState(null);\n    const [debugInfo, setDebugInfo] = useState({});\n\n    const videoConstraints = {\n        width: 640,\n        height: 480,\n        facingMode: 'user',\n    };\n\n    const calculatePoseAccuracy = (userLandmarks, targetPose) => {\n        if (!targetPose || !userLandmarks) {\n            console.log('Missing data:', { hasTargetPose: !!targetPose, hasUserLandmarks: !!userLandmarks });\n            return { total: 0, segments: {} };\n        }\n\n        // Add debug logging\n        console.log('Calculating accuracy with:', {\n            userLandmarksCount: userLandmarks.length,\n            targetPoseLandmarksCount: targetPose.landmarks.length\n        });\n\n        // Define body segments with their corresponding landmark indices\n        const bodySegments = {\n            head: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n            upperBody: [11, 12, 13, 14, 15, 16],\n            torso: [11, 12, 23, 24],\n            lowerBody: [23, 24, 25, 26, 27, 28]\n        };\n\n        // Define key points that must be visible for each segment\n        const requiredPoints = {\n            head: [0], // Only require nose\n            upperBody: [11, 12], // Shoulders\n            torso: [11, 24], // One shoulder and opposite hip\n            lowerBody: [24, 26] // One hip and opposite knee\n        };\n\n        // Helper function to normalize pose relative to height\n        const normalizePose = (landmarks) => {\n            // Find the topmost and bottommost visible points\n            let minY = Number.MAX_VALUE;\n            let maxY = Number.MIN_VALUE;\n            let minX = Number.MAX_VALUE;\n            let maxX = Number.MIN_VALUE;\n\n            landmarks.forEach(landmark => {\n                if (landmark.visibility > 0.3) {\n                    minY = Math.min(minY, landmark.y);\n                    maxY = Math.max(maxY, landmark.y);\n                    minX = Math.min(minX, landmark.x);\n                    maxX = Math.max(maxX, landmark.x);\n                }\n            });\n\n            const height = maxY - minY;\n            const width = maxX - minX;\n            const centerX = (minX + maxX) / 2;\n            const centerY = (minY + maxY) / 2;\n\n            if (height === 0 || width === 0) return landmarks;\n\n            return landmarks.map(landmark => ({\n                x: (landmark.x - centerX) / width,\n                y: (landmark.y - centerY) / height,\n                visibility: landmark.visibility\n            }));\n        };\n\n        // Normalize both poses\n        const normalizedUser = normalizePose(userLandmarks);\n        const normalizedTarget = normalizePose(targetPose.landmarks);\n\n        let segmentAccuracies = {};\n        let visibleSegments = 0;\n\n        // Calculate accuracy for each body segment\n        for (const [segment, points] of Object.entries(bodySegments)) {\n            // Check if required points are visible\n            const requiredVisible = requiredPoints[segment].every(index => {\n                const userPoint = normalizedUser[index];\n                const targetPoint = normalizedTarget[index];\n                return userPoint.visibility > 0.3 && targetPoint.visibility > 0.3;\n            });\n\n            if (!requiredVisible) continue;\n\n            let segmentTotal = 0;\n            let segmentPoints = 0;\n\n            // Calculate accuracies for points\n            points.forEach(index => {\n                const userLandmark = normalizedUser[index];\n                const targetLandmark = normalizedTarget[index];\n\n                // Lower visibility threshold for legs\n                const visibilityThreshold = segment === 'lowerBody' ? 0.3 : 0.4;\n\n                if (userLandmark.visibility > visibilityThreshold && targetLandmark.visibility > visibilityThreshold) {\n                    // Calculate position difference\n                    const distance = Math.sqrt(\n                        Math.pow(userLandmark.x - targetLandmark.x, 2) +\n                        Math.pow(userLandmark.y - targetLandmark.y, 2)\n                    );\n\n                    // Calculate relative angle to center\n                    const userAngle = Math.atan2(userLandmark.y, userLandmark.x);\n                    const targetAngle = Math.atan2(targetLandmark.y, targetLandmark.x);\n                    const angleDiff = Math.abs(userAngle - targetAngle);\n\n                    // Adjust weights based on segment\n                    let angleWeight = 0.5;\n                    let distanceWeight = 0.5;\n\n                    if (segment === 'lowerBody') {\n                        angleWeight = 0.7;  // More emphasis on angle for legs\n                        distanceWeight = 0.3;\n                    }\n\n                    // Calculate point accuracy\n                    const angleAccuracy = Math.max(0, 1 - (angleDiff / Math.PI));\n                    const distanceAccuracy = Math.max(0, 1 - (distance / 1.0)); // Increased tolerance\n                    const pointAccuracy = (angleAccuracy * angleWeight + distanceAccuracy * distanceWeight);\n\n                    // Use visibility for accuracy weight but count point as fully visible\n                    const visibilityWeight = Math.min(userLandmark.visibility, targetLandmark.visibility);\n                    segmentTotal += pointAccuracy * visibilityWeight;\n                    segmentPoints += 1; // Count as one visible point instead of using visibility value\n                }\n            });\n\n            // Calculate segment accuracy if we have points\n            if (segmentPoints > 0) {\n                const rawAccuracy = (segmentTotal / segmentPoints) * 100;\n\n                // Calculate visibility as a weighted average based on point importance\n                const visibilityWeight = points.reduce((sum, index) => {\n                    const landmark = normalizedUser[index];\n                    // Use a more lenient visibility threshold and smooth the transition\n                    return sum + (landmark.visibility > 0.2 ? Math.min(1, landmark.visibility * 1.5) : 0);\n                }, 0);\n\n                const visibilityPercentage = (visibilityWeight / points.length);\n\n                segmentAccuracies[segment] = {\n                    accuracy: Math.min(100, Math.max(0, rawAccuracy)),\n                    visibility: visibilityPercentage\n                };\n                visibleSegments++;\n            }\n        }\n\n        // Calculate overall accuracy with adjusted weights\n        if (visibleSegments === 0) return { total: 0, segments: {} };\n\n        let totalAccuracy = 0;\n        let totalWeight = 0;\n\n        const segmentWeights = {\n            head: 0.8,\n            upperBody: 1.0,\n            torso: 1.0,\n            lowerBody: 1.2\n        };\n\n        for (const [segment, data] of Object.entries(segmentAccuracies)) {\n            const weight = segmentWeights[segment] * Math.pow(data.visibility, 0.5); // Sqrt to reduce penalty of low visibility\n            totalAccuracy += data.accuracy * weight;\n            totalWeight += weight;\n        }\n\n        // Add more detailed debug info\n        setDebugInfo({\n            visibleSegments,\n            segmentAccuracies,\n            userLandmarksPresent: userLandmarks.length,\n            targetLandmarksPresent: targetPose.landmarks.length\n        });\n\n        return {\n            total: Math.round(totalWeight > 0 ? totalAccuracy / totalWeight : 0),\n            segments: segmentAccuracies\n        };\n    };\n\n    const onResults = useCallback((results) => {\n        if (!canvasRef.current || !results.poseLandmarks) {\n            console.log('Missing canvas or landmarks');\n            return;\n        }\n\n        // Log the incoming data\n        console.log('Received pose landmarks:', {\n            landmarksCount: results.poseLandmarks.length,\n            hasSelectedPose: !!selectedPose,\n            selectedPoseLandmarks: selectedPose?.landmarks?.length\n        });\n\n        const canvasElement = canvasRef.current;\n        const canvasCtx = canvasElement.getContext('2d');\n        const videoWidth = webcamRef.current.video.videoWidth;\n        const videoHeight = webcamRef.current.video.videoHeight;\n\n        // Set canvas dimensions to match video\n        canvasElement.width = videoWidth;\n        canvasElement.height = videoHeight;\n\n        // Calculate pose accuracy if we have a selected pose\n        if (selectedPose && selectedPose.landmarks) {\n            const accuracyData = calculatePoseAccuracy(results.poseLandmarks, selectedPose);\n            setPoseAccuracy(accuracyData.total);\n            setSegmentAccuracies(accuracyData.segments);\n        }\n\n        // Clear canvas\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n        // Draw pose landmarks\n        if (results.poseLandmarks) {\n            // Save the current context state\n            canvasCtx.save();\n\n            // Clear the canvas\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n            // Mirror the context\n            canvasCtx.scale(-1, 1);\n            canvasCtx.translate(-videoWidth, 0);\n\n            // Draw pose connections with adjusted line width based on video dimensions\n            function drawConnection(landmarks, start, end, color) {\n                const startPoint = landmarks[start];\n                const endPoint = landmarks[end];\n\n                if (startPoint.visibility > 0.5 && endPoint.visibility > 0.5) {\n                    canvasCtx.beginPath();\n                    canvasCtx.moveTo(\n                        startPoint.x * videoWidth,\n                        startPoint.y * videoHeight\n                    );\n                    canvasCtx.lineTo(\n                        endPoint.x * videoWidth,\n                        endPoint.y * videoHeight\n                    );\n                    canvasCtx.strokeStyle = color;\n                    // Adjust line width based on video dimensions\n                    canvasCtx.lineWidth = Math.max(3, videoWidth / 200);\n                    canvasCtx.stroke();\n                }\n            }\n\n            const landmarks = results.poseLandmarks;\n\n            // Draw body parts with different colors\n            // Upper body (green)\n            const upperBodyColor = '#00FF00';\n            drawConnection(landmarks, 12, 11, upperBodyColor); // shoulders\n            drawConnection(landmarks, 12, 14, upperBodyColor); // right upper arm\n            drawConnection(landmarks, 14, 16, upperBodyColor); // right lower arm\n            drawConnection(landmarks, 11, 13, upperBodyColor); // left upper arm\n            drawConnection(landmarks, 13, 15, upperBodyColor); // left lower arm\n\n            // Head (red)\n            const headColor = '#FF0000';\n            drawConnection(landmarks, 0, 4, headColor);\n            drawConnection(landmarks, 4, 5, headColor);\n            drawConnection(landmarks, 5, 6, headColor);\n            drawConnection(landmarks, 6, 8, headColor);\n            drawConnection(landmarks, 0, 1, headColor);\n            drawConnection(landmarks, 1, 2, headColor);\n            drawConnection(landmarks, 2, 3, headColor);\n            drawConnection(landmarks, 3, 7, headColor);\n\n            // Torso (blue)\n            const torsoColor = '#0000FF';\n            drawConnection(landmarks, 12, 24, torsoColor); // right shoulder to hip\n            drawConnection(landmarks, 11, 23, torsoColor); // left shoulder to hip\n            drawConnection(landmarks, 24, 23, torsoColor); // hips\n\n            // Lower body (yellow)\n            const lowerBodyColor = '#FFFF00';\n            drawConnection(landmarks, 24, 26, lowerBodyColor); // right hip to knee\n            drawConnection(landmarks, 26, 28, lowerBodyColor); // right knee to ankle\n            drawConnection(landmarks, 23, 25, lowerBodyColor); // left hip to knee\n            drawConnection(landmarks, 25, 27, lowerBodyColor); // left knee to ankle\n\n            // Draw landmarks with size relative to video dimensions\n            landmarks.forEach((landmark) => {\n                if (landmark.visibility > 0.5) {\n                    canvasCtx.beginPath();\n                    const pointSize = Math.max(5, videoWidth / 100);\n                    canvasCtx.arc(\n                        landmark.x * videoWidth,\n                        landmark.y * videoHeight,\n                        pointSize,\n                        0,\n                        2 * Math.PI\n                    );\n                    canvasCtx.fillStyle = '#FFFFFF';\n                    canvasCtx.fill();\n                    canvasCtx.strokeStyle = '#000000';\n                    canvasCtx.lineWidth = Math.max(2, videoWidth / 400);\n                    canvasCtx.stroke();\n                }\n            });\n\n            // Restore the context state\n            canvasCtx.restore();\n        }\n    }, [selectedPose]);\n\n    useEffect(() => {\n        let pose = null;\n        let camera = null;\n\n        const initializePose = async () => {\n            try {\n                // Create pose detector with updated initialization\n                pose = new Pose({\n                    locateFile: (file) => {\n                        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${file}`;\n                    }\n                });\n\n                // Configure pose detection - set selfieMode to false to prevent double mirroring\n                await pose.setOptions({\n                    modelComplexity: 1,\n                    smoothLandmarks: true,\n                    minDetectionConfidence: 0.5,\n                    minTrackingConfidence: 0.5,\n                    selfieMode: false  // Changed to false to prevent double mirroring\n                });\n\n                // Set up result handler\n                await pose.onResults(onResults);\n\n                // Initialize camera after pose is ready\n                if (webcamRef.current && webcamRef.current.video) {\n                    camera = new Camera(webcamRef.current.video, {\n                        onFrame: async () => {\n                            try {\n                                if (webcamRef.current && webcamRef.current.video) {\n                                    await pose.send({ image: webcamRef.current.video });\n                                }\n                            } catch (err) {\n                                console.error('Error in camera frame processing:', err);\n                            }\n                        },\n                        width: 640,\n                        height: 480\n                    });\n\n                    await camera.start();\n                    setIsLoading(false);\n                }\n            } catch (err) {\n                console.error('Error initializing pose detection:', err);\n                setError('Failed to initialize pose detection. Please try refreshing the page.');\n                setIsLoading(false);\n            }\n        };\n\n        // Initialize pose detection\n        initializePose();\n\n        // Cleanup function\n        return () => {\n            if (camera) {\n                camera.stop();\n            }\n            if (pose) {\n                pose.close();\n            }\n        };\n    }, [onResults]);\n\n    useEffect(() => {\n        // Initialize WebSocket connection\n        const ws = new WebSocket('ws://localhost:8000/ws/pose-feedback');\n\n        ws.onopen = () => {\n            console.log('Connected to feedback server');\n            setWsConnection(ws);\n        };\n\n        ws.onmessage = (event) => {\n            setPoseFeedback(event.data);\n        };\n\n        ws.onerror = (error) => {\n            console.error('WebSocket error:', error);\n        };\n\n        return () => {\n            if (ws) {\n                ws.close();\n            }\n        };\n    }, []);\n\n    // Send pose data to backend when accuracy updates\n    useEffect(() => {\n        if (wsConnection && selectedPose && Object.keys(segmentAccuracies).length > 0) {\n            const poseData = {\n                pose_name: selectedPose.name || 'unknown pose',\n                overall_accuracy: poseAccuracy,\n                segment_accuracies: segmentAccuracies\n            };\n            wsConnection.send(JSON.stringify(poseData));\n        }\n    }, [poseAccuracy, segmentAccuracies, selectedPose, wsConnection]);\n\n    // Load initial pose\n    useEffect(() => {\n        const loadPose = async () => {\n            try {\n                // For testing, we'll load a specific pose\n                const response = await fetch('/pose_results/tree-pose_pose.json');\n                if (!response.ok) {\n                    throw new Error('Failed to load pose data');\n                }\n                const poseData = await response.json();\n                console.log('Loaded pose data:', poseData);\n                setSelectedPose(poseData);\n            } catch (err) {\n                console.error('Error loading pose data:', err);\n                setError('Failed to load pose data');\n            }\n        };\n\n        loadPose();\n    }, []);\n\n    return (\n        <div className=\"pose-tracker\">\n            {isLoading && (\n                <div className=\"loading\">\n                    <p>Loading pose detector... Please wait a moment.</p>\n                    <p style={{ fontSize: '0.9em', color: '#666' }}>\n                        This may take a few seconds to initialize.\n                    </p>\n                </div>\n            )}\n            {error && (\n                <div className=\"error\">\n                    <p>{error}</p>\n                    <button\n                        onClick={() => window.location.reload()}\n                        className=\"retry-button\"\n                    >\n                        Retry\n                    </button>\n                </div>\n            )}\n            <div className=\"camera-container\">\n                <Webcam\n                    ref={webcamRef}\n                    className=\"webcam\"\n                    mirrored={true}\n                    videoConstraints={videoConstraints}\n                />\n                <canvas ref={canvasRef} className=\"pose-canvas\" />\n\n                {/* Add debug info display */}\n                <div className=\"debug-info\">\n                    <div>Selected Pose: {selectedPose ? 'Loaded' : 'Not Loaded'}</div>\n                    <div>Landmarks: {selectedPose?.landmarks ? selectedPose.landmarks.length : 'None'}</div>\n                    <div>Visible Segments: {debugInfo.visibleSegments || 0}</div>\n                    <div>User Landmarks: {debugInfo.userLandmarksPresent || 0}</div>\n                </div>\n\n                {/* Accuracy Display - Now always visible */}\n                <div className=\"accuracy-display\" style={{\n                    position: 'absolute',\n                    top: '10px',\n                    right: '10px',\n                    background: 'rgba(0,0,0,0.7)',\n                    color: 'white',\n                    padding: '15px',\n                    borderRadius: '5px',\n                    minWidth: '200px'\n                }}>\n                    <div className=\"accuracy-overall\" style={{ fontSize: '18px', marginBottom: '10px' }}>\n                        Overall Accuracy: {poseAccuracy}%\n                    </div>\n                    <div className=\"accuracy-segments\">\n                        {Object.entries(segmentAccuracies).map(([segment, data]) => (\n                            <div key={segment} className=\"accuracy-segment\" style={{\n                                marginBottom: '5px',\n                                display: 'flex',\n                                justifyContent: 'space-between'\n                            }}>\n                                <span>{segment.charAt(0).toUpperCase() + segment.slice(1)}:</span>\n                                <span>{Math.round(data.accuracy)}% ({Math.round(data.visibility * 100)}% visible)</span>\n                            </div>\n                        ))}\n                    </div>\n                    {Object.keys(segmentAccuracies).length === 0 && (\n                        <div style={{ color: '#ff9999', marginTop: '10px' }}>\n                            No segments detected. Make sure your full body is visible in the camera.\n                        </div>\n                    )}\n                    {poseFeedback && (\n                        <div className=\"pose-feedback\" style={{ marginTop: '15px', borderTop: '1px solid rgba(255,255,255,0.3)', paddingTop: '10px' }}>\n                            <div className=\"feedback-title\" style={{ fontWeight: 'bold', marginBottom: '5px' }}>\n                                Instructor Feedback:\n                            </div>\n                            {poseFeedback}\n                        </div>\n                    )}\n                </div>\n            </div>\n        </div>\n    );\n};\n\nexport default PoseTracker;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}